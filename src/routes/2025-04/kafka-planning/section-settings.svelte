<script>
	import Notes from '$lib/deck/notes.svelte';
	import Slide from '$lib/deck/slide.svelte';

	export let assetsDir = '';
	export let defaultBgOpacity = '0.5';
</script>

<Slide bgImage="{assetsDir}/bg-topics-and-partitions.webp" bgImageOpacity={defaultBgOpacity}>
	<Slide>
		<div class="flex h-full items-center justify-center">
			<div class="text-7xl font-bold">Настройки</div>
		</div>
		<Notes>
			В этом разделе мы рассмотрим ключевые настройки и параметры Apache Kafka, которые необходимо
			учитывать при проектировании и эксплуатации систем на базе этой платформы.
		</Notes>
	</Slide>
	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Retention</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Два типа политик</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">По времени (log.retention.hours)</li>
						<li class="text-2xl">По размеру (log.retention.bytes)</li>
					</ul>
				</li>
				<li class="text-2xl">
					<strong>Увеличивать для</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">Аналитики исторических данных</li>
						<li class="text-2xl">Бизнес-требований по хранению</li>
					</ul>
				</li>
				<li class="text-2xl">
					<strong>Ограничивать при</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">Быстром устаревании данных</li>
						<li class="text-2xl">Ограниченных ресурсах</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			{`
			Retention (политика хранения) в Kafka определяет, как долго или в каком объеме сообщения
			хранятся в топиках. Существует два основных типа политик retention: 
			1. Time-based retention (log.retention.hours):
				- Определяет, сколько времени сообщения хранятся в топике
				- По умолчанию: 168 часов (7 дней)
				- После истечения указанного периода, сообщения удаляются независимо от того, были ли они прочитаны
			2. Size-based retention (log.retention.bytes):
				- Определяет максимальный размер данных для партиции
				- Когда размер превышается, старые сообщения удаляются
				- По умолчанию: -1 (неограниченно, применяется только time-based retention)
			Политики могут применяться одновременно — сработает та, которая наступит раньше.
			Преимущества увеличения retention:
			- Возможность "возвращаться в прошлое" и перерабатывать исторические сообщения
			- Поддержка replay-сценариев для аналитики
			- Соответствие требованиям регуляторов (например, для финансового аудита)
			Причины для ограничения retention:
			- Экономия дискового пространства при быстром устаревании данных
			- Снижение затрат на инфраструктуру
			- Оптимизация производительности при ограниченных ресурсах
			При проектировании стоит анализировать бизнес-потребности и технические ограничения, чтобы найти оптимальный баланс между обоими типами политик.
			
			Преимущества увеличения retention:
				- Возможность "возвращаться в прошлое" и перерабатывать исторические сообщения
				- Поддержка replay-сценариев для аналитики
				- Соответствие требованиям регуляторов (например, для финансового аудита)
			Причины для ограничения retention:
				- Экономия дискового пространства при быстром устаревании данных
				- Снижение затрат на инфраструктуру
				- Оптимизация производительности при ограниченных ресурсах
			При проектировании стоит анализировать бизнес-потребности и технические ограничения, чтобы найти оптимальный баланс между обоими типами политик.
			между обоими типами политик.
			`}
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Количество партиций</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Формула</strong>: (Требуемая пропускная способность) / (Пропускная способность
					одной партиции)
				</li>
				<li class="text-2xl">
					<strong>Партиции ≥ Консьюмеров</strong> в группе
				</li>
				<li class="text-2xl">
					<strong>Рекомендации</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">Начинать с 1-3 на топик для простых случаев</li>
						<li class="text-2xl">До 10-30 на топик для типичных нагрузок</li>
						<li class="text-2xl">Максимум ~1000-2000 на брокер в кластере</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			Определение оптимального количества партиций — один из ключевых вопросов архитектуры Kafka.
			Основные принципы: 1. Количество партиций = требуемая пропускная способность / пропускная
			способность одной партиции 2. Партиций должно быть не меньше числа консьюмеров в группе для
			параллельной обработки Рекомендации: - Небольшая нагрузка: 1-3 партиции на топик - Типичные
			приложения: 10-30 партиций на топик - Высокая нагрузка: до 100 партиций (редкий случай)
			Ограничения: - Максимальное количество: 1000-2000 партиций на брокер (суммарно) - Слишком
			много партиций вызывает проблемы с ребалансировкой, нагрузку на Zookeeper, расход памяти
			Стратегия: сначала оптимизируйте обработку, затем увеличивайте число партиций. Увеличить
			легко, уменьшить почти невозможно.
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Особенности партиций</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Параллельная обработка</strong>
				</li>
				<li class="text-2xl">
					<strong>Сохранение порядка</strong> внутри партиции
				</li>
				<li class="text-2xl">
					<strong>Проблемы избытка</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">Overhead на метаданные</li>
						<li class="text-2xl">Медленная ребалансировка</li>
						<li class="text-2xl">Фрагментация данных</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			Партиции – фундаментальная единица параллелизма в Kafka, которая обеспечивает масштабируемость
			системы. Ключевые преимущества: - Горизонтальное масштабирование: чем больше партиций, тем
			больше консьюмеров могут читать данные параллельно - Упорядоченность: сообщения внутри одной
			партиции всегда доставляются в порядке их поступления - Локализация данных: при правильном
			выборе ключа (partition key) связанные данные группируются в одну партицию Проблемы при
			избыточном количестве партиций: - Увеличение нагрузки на ZooKeeper/Controller из-за метаданных
			- Замедление ребалансировки при добавлении/удалении консьюмеров или при сбоях - Фрагментация
			усложняет обработку связанных данных, если они оказываются в разных партициях Оптимальное
			количество партиций – результат компромисса между масштабируемостью и операционной сложностью.
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Стратегии партиционирования</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Round-robin</strong>: равномерное распределение
				</li>
				<li class="text-2xl">
					<strong>Key-based</strong>: одинаковые ключи → одна партиция
				</li>
				<li class="text-2xl">
					<strong>Custom</strong>: собственная логика
				</li>
				<li class="text-2xl">
					<strong>Выбор стратегии</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">Порядок событий → Key-based</li>
						<li class="text-2xl">Максимальная скорость → Round-robin</li>
						<li class="text-2xl">Специальная группировка → Custom</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			Выбор стратегии партиционирования существенно влияет на работу системы. Существует три
			основных подхода: 1. Round-robin (по умолчанию): - Сообщения распределяются равномерно между
			партициями - Максимально эффективное использование ресурсов - Не гарантирует порядок связанных
			сообщений 2. Key-based (по ключу): - Сообщения с одинаковым ключом попадают в одну партицию -
			Гарантирует порядок сообщений с одинаковым ключом - Может приводить к неравномерной нагрузке
			(skewed partitions) 3. Custom (кастомное партиционирование): - Реализация собственной логики
			распределения - Позволяет учитывать специфические бизнес-требования - Требует дополнительной
			разработки и тестирования Рекомендации по выбору: - Для финансовых транзакций или событий, где
			порядок критичен → Key-based - Для высоконагруженных систем с фокусом на пропускную
			способность → Round-robin - Для сложных сценариев с нестандартной группировкой → Custom
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Replication Factor</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Отказоустойчивость</strong>: лидер → фолловер
				</li>
				<li class="text-2xl">
					<strong>Оптимальное значение</strong>: RF = 3
				</li>
				<li class="text-2xl">
					<strong>Влияние на хранилище</strong>: объём данных × RF
				</li>
			</ul>
		</div>
		<Notes>
			Replication Factor (RF) – ключевой параметр надежности в Kafka, определяющий количество копий
			каждой партиции. Принцип работы: - Каждая партиция имеет одного лидера и несколько фолловеров
			(реплик) - При выходе из строя лидера один из фолловеров автоматически становится новым
			лидером - Чем выше RF, тем выше отказоустойчивость системы Рекомендации: - RF = 3 считается
			золотым стандартом для production-систем - RF = 2 может использоваться для менее критичных
			данных - RF = 1 не рекомендуется для production (отсутствие отказоустойчивости) Важно
			учитывать, что каждая дополнительная реплика линейно увеличивает требования к дисковому
			пространству. При RF = 3 весь объем данных хранится в трех копиях, что необходимо учитывать
			при планировании инфраструктуры.
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Конфигурация репликации</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Replication Factor</strong>: 3 (стандарт для production)
				</li>
				<li class="text-2xl">
					<strong>min.insync.replicas</strong>: минимум реплик для подтверждения
				</li>
				<li class="text-2xl">
					<strong>Надёжная конфигурация</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">RF=3 + min.insync.replicas=2 + acks=all</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			Конфигурация репликации – критически важный аспект проектирования надежной системы на базе
			Kafka. Основные параметры: 1. Replication Factor (RF): - Определяет общее количество копий
			каждой партиции - RF=3 является стандартом для production-среды - Обеспечивает высокую
			доступность даже при выходе из строя двух брокеров 2. min.insync.replicas: - Указывает
			минимальное количество синхронизированных реплик для успешной записи при acks=all - Значение 2
			обычно используется с RF=3 - Защищает от потери данных при сбоях 3. Взаимодействие с acks: -
			При acks=all и min.insync.replicas=2: запись успешна только если сохранена минимум на двух
			репликах - Если количество доступных синхронизированных реплик меньше min.insync.replicas,
			продюсеры получат NotEnoughReplicas ошибку Надежная конфигурация для критически важных систем:
			- RF=3 + min.insync.replicas=2 + acks=all - Обеспечивает устойчивость к потере одного брокера
			без потери данных - Останавливает запись при потере двух брокеров вместо риска потери данных
			Этот набор настроек обеспечивает оптимальный баланс между надежностью и доступностью.
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Acknowledgments (acks)</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Уровни</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">
							<strong>acks=0</strong>: без ожидания (скорость > надёжность)
						</li>
						<li class="text-2xl">
							<strong>acks=1</strong>: подтверждение от лидера (баланс)
						</li>
						<li class="text-2xl">
							<strong>acks=all</strong>: от всех in-sync реплик (надёжность > скорость)
						</li>
					</ul>
				</li>
				<li class="text-2xl">
					<strong>Критичные системы</strong>: обычно acks=all
				</li>
			</ul>
		</div>
		<Notes>
			Параметр acknowledgments (acks) определяет компромисс между надежностью и производительностью
			при записи данных. Три возможных значения: 1. acks=0: - Продюсер отправляет сообщение и не
			ждет подтверждений - Максимальная пропускная способность и минимальная задержка - Высокий риск
			потери данных при сбоях брокера - Подходит для логирования, метрик, где потеря части данных
			допустима 2. acks=1: - Продюсер ждет подтверждения только от лидера партиции - Разумный баланс
			между надежностью и производительностью - Возможна потеря данных при сбое лидера до репликации
			- Подходит для большинства бизнес-приложений 3. acks=all (или acks=-1): - Подтверждение от
			всех синхронизированных реплик (ISR) - Максимальная надежность, но ниже производительность -
			Минимальный риск потери данных - Необходим для финансовых транзакций, медицинских данных и
			других критичных систем В сочетании с настройкой min.insync.replicas можно точно
			контролировать гарантии надежности.
		</Notes>
	</Slide>

	<Slide>
		<div class="flex flex-col items-center">
			<div class="mb-12 text-5xl font-semibold">Оптимизация продюсера</div>
			<ul class="w-4/5 space-y-6">
				<li class="text-2xl">
					<strong>Batch size</strong>: объединение сообщений
				</li>
				<li class="text-2xl">
					<strong>linger.ms</strong>: задержка для формирования пакета
				</li>
				<li class="text-2xl">
					<strong>Сжатие</strong>:
					<ul class="ml-8 mt-3 space-y-3">
						<li class="text-2xl">gzip: максимальное сжатие, высокое CPU</li>
						<li class="text-2xl">snappy/lz4: баланс сжатия и скорости</li>
						<li class="text-2xl">zstd: новый алгоритм, высокая эффективность</li>
					</ul>
				</li>
			</ul>
		</div>
		<Notes>
			Настройки продюсера имеют значительное влияние на производительность и эффективность системы:
			1. Batch size: - Определяет максимальный размер пакета сообщений для отправки за один раз -
			Большие пакеты улучшают пропускную способность за счет меньшего количества сетевых вызовов -
			При увеличении batch size растет латентность отдельных сообщений - Рекомендуемые значения:
			16KB-128KB в зависимости от требований к латентности 2. linger.ms: - Время ожидания перед
			отправкой неполного пакета - 0 мс (по умолчанию): отправка сразу, без ожидания заполнения
			пакета - Увеличение значения уменьшает количество запросов, но повышает задержку - Типичные
			значения: 5-100 мс для оптимизации пропускной способности 3. Сжатие (compression): - gzip:
			высокая степень сжатия, но большая нагрузка на CPU - snappy: средняя степень сжатия, хорошая
			скорость, баланс между ресурсами и эффективность - lz4: быстрое сжатие/распаковка, хорошо для
			высоконагруженных систем - zstd: новый алгоритм с хорошим балансом между сжатием и
			производительностью Оптимальная стратегия: установить разумный batch size, добавить небольшой
			linger.ms (5-10 мс) и использовать сжатие snappy или lz4 для большинства систем.
		</Notes>
	</Slide>
</Slide>
