import{s as nt,n as ct}from"../chunks/scheduler.DypdDQBO.js";import{S as at,i as it,v as h,w,x as k,m as v,n as b,y as K,s as x,j as _,f as u,d as c,e as T,c as R,z as V,b as C,t as O,h as y,a as J,k as L,r as ot,p as ut,g as mt}from"../chunks/index.D01Odw2v.js";import{b as pt}from"../chunks/paths.DcaYrCjo.js";import{b as B,N as E,S as gt,a as dt}from"../chunks/SocialIcons.CWHn959N.js";import{e as rt}from"../chunks/each.D6YF6ztN.js";function xt(r){let t;return{c(){t=O(`Сейчас мы рассмотрим архитектуру Kafka и ее основные компоненты, чтобы лучше понимать, как она
			работает и какие преимущества предоставляет для построения распределенных систем.`)},l(s){t=y(s,`Сейчас мы рассмотрим архитектуру Kafka и ее основные компоненты, чтобы лучше понимать, как она
			работает и какие преимущества предоставляет для построения распределенных систем.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function _t(r){let t,s='<div class="text-7xl font-bold">Архитектура Kafka</div>',l,n,a;return n=new E({props:{$$slots:{default:[xt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-3tlmng"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function vt(r){let t;return{c(){t=O(`Кластер Kafka — это набор узлов (брокеров), которые совместно хранят и обрабатывают сообщения.
			Топик — логическая очередь для сообщений, куда продюсеры записывают события, а консьюмеры их
			читают. Каждый топик разбит на партиции, что позволяет масштабировать обработку. Партиции
			представляют собой физические мини-очереди, которые хранят сообщения в порядке добавления
			(append-only лог). Клиенты могут параллельно читать данные из разных партиций, значительно
			увеличивая пропускную способность.`)},l(s){t=y(s,`Кластер Kafka — это набор узлов (брокеров), которые совместно хранят и обрабатывают сообщения.
			Топик — логическая очередь для сообщений, куда продюсеры записывают события, а консьюмеры их
			читают. Каждый топик разбит на партиции, что позволяет масштабировать обработку. Партиции
			представляют собой физические мини-очереди, которые хранят сообщения в порядке добавления
			(append-only лог). Клиенты могут параллельно читать данные из разных партиций, значительно
			увеличивая пропускную способность.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function bt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Основные компоненты</div> <ul class="w-4/5 space-y-6"><li class="text-3xl"><strong>Кластер</strong>: Набор брокеров для хранения сообщений</li> <li class="text-3xl"><strong>Топики</strong>: Логические очереди событий</li> <li class="text-3xl"><strong>Партиции</strong>: Единицы параллелизма внутри топиков</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[vt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-mryrj2"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ht(r){let t;return{c(){t=O(`Продьюсер — приложение, отправляющее сообщения в топик. Ключевые особенности: - Может выбирать
			ключ сообщения, определяющий целевую партицию - Настраивает уровни подтверждения (acks) для
			баланса между производительностью и надёжностью - При отсутствии ключа распределяет сообщения
			между партициями по round-robin или случайно Консьюмер — приложение, читающее сообщения из
			топика: - В группе потребителей автоматически распределяет партиции между участниками - Каждая
			партиция может быть назначена только одному консьюмеру в группе - Отслеживает offset (позицию)
			в каждой партиции, позволяя возобновлять чтение с нужного места - При подтверждении offset-а
			Kafka фиксирует прогресс обработки`)},l(s){t=y(s,`Продьюсер — приложение, отправляющее сообщения в топик. Ключевые особенности: - Может выбирать
			ключ сообщения, определяющий целевую партицию - Настраивает уровни подтверждения (acks) для
			баланса между производительностью и надёжностью - При отсутствии ключа распределяет сообщения
			между партициями по round-robin или случайно Консьюмер — приложение, читающее сообщения из
			топика: - В группе потребителей автоматически распределяет партиции между участниками - Каждая
			партиция может быть назначена только одному консьюмеру в группе - Отслеживает offset (позицию)
			в каждой партиции, позволяя возобновлять чтение с нужного места - При подтверждении offset-а
			Kafka фиксирует прогресс обработки`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function wt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Продьюсеры и Консьюмеры</div> <div class="flex w-full justify-around"><div class="w-2/5"><div class="mb-4 text-3xl font-bold">Продьюсер</div> <ul class="space-y-3"><li class="text-2xl">Отправляет сообщения</li> <li class="text-2xl">Выбирает партицию</li> <li class="text-2xl">Настраивает надёжность</li></ul></div> <div class="w-2/5"><div class="mb-4 text-3xl font-bold">Консьюмер</div> <ul class="space-y-3"><li class="text-2xl">Читает сообщения</li> <li class="text-2xl">Работает в группах</li> <li class="text-2xl">Отслеживает offset</li></ul></div></div>',l,n,a;return n=new E({props:{$$slots:{default:[ht]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-mqhktn"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function kt(r){let t;return{c(){t=O(`Репликация в Kafka — каждая партиция хранится на нескольких брокерах для обеспечения
			отказоустойчивости. Лидер обслуживает все операции чтения/записи, а фолловеры синхронизируют
			данные. Можно настроить количество синхронизированных реплик, необходимых для подтверждения
			записи. При сбое брокера фолловер автоматически становится лидером, обеспечивая непрерывность
			работы. Контроллер (выбранный брокер) координирует этот процесс. Retention policy определяет,
			как долго сообщения хранятся в системе — они удаляются по истечении настроенного времени или
			при превышении настроенного размера топика. Важно: Kafka удаляет целые сегменты партиции, а не
			отдельные сообщения, что нужно учитывать при планировании дискового пространства.`)},l(s){t=y(s,`Репликация в Kafka — каждая партиция хранится на нескольких брокерах для обеспечения
			отказоустойчивости. Лидер обслуживает все операции чтения/записи, а фолловеры синхронизируют
			данные. Можно настроить количество синхронизированных реплик, необходимых для подтверждения
			записи. При сбое брокера фолловер автоматически становится лидером, обеспечивая непрерывность
			работы. Контроллер (выбранный брокер) координирует этот процесс. Retention policy определяет,
			как долго сообщения хранятся в системе — они удаляются по истечении настроенного времени или
			при превышении настроенного размера топика. Важно: Kafka удаляет целые сегменты партиции, а не
			отдельные сообщения, что нужно учитывать при планировании дискового пространства.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Kt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Отказоустойчивость</div> <ul class="w-4/5 space-y-6"><li class="text-3xl"><strong>Репликация</strong>: Копии данных на разных брокерах</li> <li class="text-3xl"><strong>Лидер/Фолловеры</strong>: Модель координации реплик</li> <li class="text-3xl"><strong>Автоматическое восстановление</strong> при сбоях</li> <li class="text-3xl"><strong>Retention Policy</strong>: Управление жизненным циклом данных</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[kt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-1jrhwwh"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function It(r){let t,s,l,n,a,e,i,f;return t=new B({props:{$$slots:{default:[_t]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[bt]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[wt]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[Kt]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment)},l($){w(t.$$.fragment,$),s=_($),w(l.$$.fragment,$),n=_($),w(a.$$.fragment,$),e=_($),w(i.$$.fragment,$)},m($,m){k(t,$,m),u($,s,m),k(l,$,m),u($,n,m),k(a,$,m),u($,e,m),k(i,$,m),f=!0},p($,m){const g={};m&4&&(g.$$scope={dirty:m,ctx:$}),t.$set(g);const d={};m&4&&(d.$$scope={dirty:m,ctx:$}),l.$set(d);const p={};m&4&&(p.$$scope={dirty:m,ctx:$}),a.$set(p);const I={};m&4&&(I.$$scope={dirty:m,ctx:$}),i.$set(I)},i($){f||(v(t.$$.fragment,$),v(l.$$.fragment,$),v(a.$$.fragment,$),v(i.$$.fragment,$),f=!0)},o($){b(t.$$.fragment,$),b(l.$$.fragment,$),b(a.$$.fragment,$),b(i.$$.fragment,$),f=!1},d($){$&&(c(s),c(n),c(e)),K(t,$),K(l,$),K(a,$),K(i,$)}}}function Dt(r){let t,s;return t=new B({props:{bgImage:r[0]+"/arch_bg.jpg",bgImageOpacity:r[1],$$slots:{default:[It]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&1&&(a.bgImage=l[0]+"/arch_bg.jpg"),n&2&&(a.bgImageOpacity=l[1]),n&4&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function Ct(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class Tt extends at{constructor(t){super(),it(this,t,Ct,Dt,nt,{assetsDir:0,defaultBgOpacity:1})}}function Rt(r){let t;return{c(){t=O(`Начнем с введения, в котором познакомимся с основными понятиями Apache Kafka и рассмотрим её
			роль в современных системах.`)},l(s){t=y(s,`Начнем с введения, в котором познакомимся с основными понятиями Apache Kafka и рассмотрим её
			роль в современных системах.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Lt(r){let t,s='<div class="text-7xl font-bold">Введение</div>',l,n,a;return n=new E({props:{$$slots:{default:[Rt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-17cfpht"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ht(r){let t;return{c(){t=O(`Apache Kafka — это высокопроизводительная система очередей сообщений с упрощённой моделью
			хранения (append-only log). Она берёт на себя роль центрального «транзитного узла» для обмена
			событиями между сервисами. Как отмечалось в предыдущем вебинаре, Kafka обеспечивает
			гарантированное хранение (благодаря репликации) и гибко масштабируется, разбивая данные на
			партиции.`)},l(s){t=y(s,`Apache Kafka — это высокопроизводительная система очередей сообщений с упрощённой моделью
			хранения (append-only log). Она берёт на себя роль центрального «транзитного узла» для обмена
			событиями между сервисами. Как отмечалось в предыдущем вебинаре, Kafka обеспечивает
			гарантированное хранение (благодаря репликации) и гибко масштабируется, разбивая данные на
			партиции.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Mt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Что такое Apache Kafka</div> <ul class="w-4/5 space-y-6"><li class="text-2xl">Высокопроизводительная система очередей сообщений</li> <li class="text-2xl">Центральный узел обмена событиями между сервисами</li> <li class="text-2xl">Надёжное хранение и масштабируемость</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[Ht]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-15anvw7"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Vt(r){let t;return{c(){t=O(`Kafka - это не классическая шина событий, а платформа потоковой передачи данных (log-centric
			streaming platform). Kafka связывает микросервисы, отправляющие и получающие события, чтобы
			ускорить взаимодействие. Высокая пропускная способность: Позволяет справляться с большими
			объёмами данных без снижения производительности. Надёжное хранение: При правильной
			конфигурации Kafka способна переживать сбои узлов благодаря механизму репликации.`)},l(s){t=y(s,`Kafka - это не классическая шина событий, а платформа потоковой передачи данных (log-centric
			streaming platform). Kafka связывает микросервисы, отправляющие и получающие события, чтобы
			ускорить взаимодействие. Высокая пропускная способность: Позволяет справляться с большими
			объёмами данных без снижения производительности. Надёжное хранение: При правильной
			конфигурации Kafka способна переживать сбои узлов благодаря механизму репликации.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Bt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Роль в современных системах</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Платформа потоковой передачи</strong> для микросервисов</li> <li class="text-2xl"><strong>Высокая пропускная способность</strong></li> <li class="text-2xl"><strong>Отказоустойчивость</strong> через репликацию</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[Vt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-1yobr95"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ot(r){let t;return{c(){t=O(`Понимание нагрузки: Аналитик должен оценивать частоту генерации событий и их структуру. От
			этого зависят настройки Kafka (партиции, ретеншн, репликация). Архитектура потоков данных:
			Описывая, какие сервисы и в каком порядке обмениваются сообщениями, аналитик учитывает логику
			интеграции и SLA, в том числе механизмы Kafka. Гибкость форматов: Kafka позволяет работать с
			JSON, Avro или Protobuf, что влияет на совместимость систем и удобство внедрения.`)},l(s){t=y(s,`Понимание нагрузки: Аналитик должен оценивать частоту генерации событий и их структуру. От
			этого зависят настройки Kafka (партиции, ретеншн, репликация). Архитектура потоков данных:
			Описывая, какие сервисы и в каком порядке обмениваются сообщениями, аналитик учитывает логику
			интеграции и SLA, в том числе механизмы Kafka. Гибкость форматов: Kafka позволяет работать с
			JSON, Avro или Protobuf, что влияет на совместимость систем и удобство внедрения.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function yt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Почему это важно для аналитика</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Понимание нагрузки</strong> и объемов данных</li> <li class="text-2xl"><strong>Архитектура потоков данных</strong> между сервисами</li> <li class="text-2xl"><strong>Форматы сообщений</strong> и их совместимость</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[Ot]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-1p1jtdx"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ft(r){let t;return{c(){t=O(`Кратко вспомним ключевые понятия (партиции, группы потребителей, топики). Расскажем о важных
			аспектах при планировании (объём диска, репликация, форматы сообщений и др.).`)},l(s){t=y(s,`Кратко вспомним ключевые понятия (партиции, группы потребителей, топики). Расскажем о важных
			аспектах при планировании (объём диска, репликация, форматы сообщений и др.).`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function jt(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Как мы будем двигаться дальше</div> <ol class="w-4/5 space-y-6"><li class="text-2xl"><strong>Кратко вспомним</strong> ключевые понятия (партиции, группы потребителей, топики)</li> <li class="text-2xl"><strong>Расскажем о важных аспектах</strong> при планировании (объём диска, репликация, форматы
					сообщений и др.)</li></ol>`,l,n,a;return n=new E({props:{$$slots:{default:[Ft]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-2t8deq"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Et(r){let t,s,l,n,a,e,i,f,$,m;return t=new B({props:{$$slots:{default:[Lt]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[Mt]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[Bt]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[yt]},$$scope:{ctx:r}}}),$=new B({props:{$$slots:{default:[jt]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment),f=x(),h($.$$.fragment)},l(g){w(t.$$.fragment,g),s=_(g),w(l.$$.fragment,g),n=_(g),w(a.$$.fragment,g),e=_(g),w(i.$$.fragment,g),f=_(g),w($.$$.fragment,g)},m(g,d){k(t,g,d),u(g,s,d),k(l,g,d),u(g,n,d),k(a,g,d),u(g,e,d),k(i,g,d),u(g,f,d),k($,g,d),m=!0},p(g,d){const p={};d&4&&(p.$$scope={dirty:d,ctx:g}),t.$set(p);const I={};d&4&&(I.$$scope={dirty:d,ctx:g}),l.$set(I);const S={};d&4&&(S.$$scope={dirty:d,ctx:g}),a.$set(S);const A={};d&4&&(A.$$scope={dirty:d,ctx:g}),i.$set(A);const H={};d&4&&(H.$$scope={dirty:d,ctx:g}),$.$set(H)},i(g){m||(v(t.$$.fragment,g),v(l.$$.fragment,g),v(a.$$.fragment,g),v(i.$$.fragment,g),v($.$$.fragment,g),m=!0)},o(g){b(t.$$.fragment,g),b(l.$$.fragment,g),b(a.$$.fragment,g),b(i.$$.fragment,g),b($.$$.fragment,g),m=!1},d(g){g&&(c(s),c(n),c(e),c(f)),K(t,g),K(l,g),K(a,g),K(i,g),K($,g)}}}function St(r){let t,s;return t=new B({props:{bgImage:r[0]+"/intro_bg.jpg",bgImageOpacity:r[1],$$slots:{default:[Et]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&1&&(a.bgImage=l[0]+"/intro_bg.jpg"),n&2&&(a.bgImageOpacity=l[1]),n&4&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function At(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class Pt extends at{constructor(t){super(),it(this,t,At,St,nt,{assetsDir:0,defaultBgOpacity:1})}}function zt(r){let t;return{c(){t=O(`В этом разделе мы рассмотрим методику расчёта необходимого объёма хранилища для Kafka
			кластера, учитывая интенсивность сообщений, их размер и требования к хранению.`)},l(s){t=y(s,`В этом разделе мы рассмотрим методику расчёта необходимого объёма хранилища для Kafka
			кластера, учитывая интенсивность сообщений, их размер и требования к хранению.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Nt(r){let t,s='<div class="text-7xl font-bold">Расчёт объёма хранилища</div>',l,n,a;return n=new E({props:{$$slots:{default:[zt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-ughovq"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function qt(r){let t;return{c(){t=O(`При проектировании Kafka-кластера важно правильно оценить объём данных, которые будут
			храниться. Для этого учитываем три ключевых параметра: 1. Частота поступления сообщений (EPS)
			- сколько событий генерируется в секунду 2. Средний размер одного сообщения - зависит от
			формата и структуры данных 3. Время хранения (Retention Period) - сколько дней или часов
			сообщения будут доступны в Kafka. Все эти факторы напрямую влияют на требуемый объём дискового
			пространства.`)},l(s){t=y(s,`При проектировании Kafka-кластера важно правильно оценить объём данных, которые будут
			храниться. Для этого учитываем три ключевых параметра: 1. Частота поступления сообщений (EPS)
			- сколько событий генерируется в секунду 2. Средний размер одного сообщения - зависит от
			формата и структуры данных 3. Время хранения (Retention Period) - сколько дней или часов
			сообщения будут доступны в Kafka. Все эти факторы напрямую влияют на требуемый объём дискового
			пространства.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Jt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Ключевые факторы</div> <ul class="w-4/5 space-y-6"><li class="text-3xl"><strong>EPS</strong>: События в секунду</li> <li class="text-3xl"><strong>Размер сообщения</strong>: Средний объём в KB</li> <li class="text-3xl"><strong>Retention Period</strong>: Время хранения</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[qt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-186s3pc"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ut(r){let t;return{c(){t=O(`Формула для расчёта необходимого дискового пространства: Объём = (Средний размер сообщения) ×
			(EPS) × (Retention в секундах) × (Replication Factor) После базового расчёта необходимо: 1.
			Добавить запас 20-30% на потенциальный рост трафика 2. Учесть фактор репликации (RF) - если
			RF=3, то итоговый объём умножается на 3, поскольку каждое сообщение хранится на трёх разных
			брокерах Важно переводить единицы измерения правильно: Retention в секунды (дни × 86400),
			размеры в согласованные единицы (байты или килобайты).`)},l(s){t=y(s,`Формула для расчёта необходимого дискового пространства: Объём = (Средний размер сообщения) ×
			(EPS) × (Retention в секундах) × (Replication Factor) После базового расчёта необходимо: 1.
			Добавить запас 20-30% на потенциальный рост трафика 2. Учесть фактор репликации (RF) - если
			RF=3, то итоговый объём умножается на 3, поскольку каждое сообщение хранится на трёх разных
			брокерах Важно переводить единицы измерения правильно: Retention в секунды (дни × 86400),
			размеры в согласованные единицы (байты или килобайты).`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Gt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Формула расчёта</div> <div class="mb-8 rounded-lg bg-black/20 p-4 font-mono text-3xl">Объём = Размер × EPS × Retention × RF</div> <ul class="w-4/5 space-y-4"><li class="text-2xl"><strong>+20-30%</strong> запаса на рост трафика</li> <li class="text-2xl"><strong>RF</strong> (Replication Factor) - умножает итоговый объём</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[Ut]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-1ltzapi"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Zt(r){let t;return{c(){t=O(`Рассмотрим два примера расчёта дискового пространства: Пример 1: - 1000 сообщений в секунду
			(EPS) - Размер сообщения: 1 KB - Retention: 7 дней - Replication Factor: 3 - Расчёт: 1000 × 1
			KB × (7 дней × 86400 сек/день) × 3 = 1,814,400,000 KB = 1,730.3 GB ≈ 1.69 ТБ (делим на 1024²
			для перевода из KB в TB) Пример 2: - 5000 сообщений в секунду - Размер сообщения: 2 KB -
			Retention: 3 дня - Replication Factor: 2 - Расчёт: 5000 × 2 KB × (3 дня × 86400 сек/день) × 2
			= 5,184,000,000 KB = 4,943.8 GB ≈ 4.83 ТБ (делим на 1024² для перевода из KB в TB) Эти примеры
			наглядно показывают, как различные параметры влияют на итоговый объём хранилища. Обратите
			внимание, что более интенсивный поток и больший размер сообщений могут значительно увеличить
			требуемое пространство даже при меньшем retention периоде.`)},l(s){t=y(s,`Рассмотрим два примера расчёта дискового пространства: Пример 1: - 1000 сообщений в секунду
			(EPS) - Размер сообщения: 1 KB - Retention: 7 дней - Replication Factor: 3 - Расчёт: 1000 × 1
			KB × (7 дней × 86400 сек/день) × 3 = 1,814,400,000 KB = 1,730.3 GB ≈ 1.69 ТБ (делим на 1024²
			для перевода из KB в TB) Пример 2: - 5000 сообщений в секунду - Размер сообщения: 2 KB -
			Retention: 3 дня - Replication Factor: 2 - Расчёт: 5000 × 2 KB × (3 дня × 86400 сек/день) × 2
			= 5,184,000,000 KB = 4,943.8 GB ≈ 4.83 ТБ (делим на 1024² для перевода из KB в TB) Эти примеры
			наглядно показывают, как различные параметры влияют на итоговый объём хранилища. Обратите
			внимание, что более интенсивный поток и больший размер сообщений могут значительно увеличить
			требуемое пространство даже при меньшем retention периоде.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Qt(r){let t,s='<div class="mb-12 text-5xl font-semibold">Примеры</div> <div class="grid w-4/5 grid-cols-2 gap-8"><div class="rounded-lg bg-black/20 p-4"><div class="mb-2 text-3xl"><strong>Случай 1</strong></div> <ul class="space-y-2"><li class="text-2xl">1000 EPS, 1 KB</li> <li class="text-2xl">7 дней, RF=3</li> <li class="mt-3 rounded bg-black/30 p-2 font-mono text-xl">1000 × 1 KB × 7 × 86400 × 3 ≈ 1.69 ТБ</li></ul></div> <div class="rounded-lg bg-black/20 p-4"><div class="mb-2 text-3xl"><strong>Случай 2</strong></div> <ul class="space-y-2"><li class="text-2xl">5000 EPS, 2 KB</li> <li class="text-2xl">3 дня, RF=2</li> <li class="mt-3 rounded bg-black/30 p-2 font-mono text-xl">5000 × 2 KB × 3 × 86400 × 2 ≈ 4.83 ТБ</li></ul></div></div>',l,n,a;return n=new E({props:{$$slots:{default:[Zt]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-dy76ro"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Wt(r){let t,s,l,n,a,e,i,f;return t=new B({props:{$$slots:{default:[Nt]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[Jt]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[Gt]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[Qt]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment)},l($){w(t.$$.fragment,$),s=_($),w(l.$$.fragment,$),n=_($),w(a.$$.fragment,$),e=_($),w(i.$$.fragment,$)},m($,m){k(t,$,m),u($,s,m),k(l,$,m),u($,n,m),k(a,$,m),u($,e,m),k(i,$,m),f=!0},p($,m){const g={};m&4&&(g.$$scope={dirty:m,ctx:$}),t.$set(g);const d={};m&4&&(d.$$scope={dirty:m,ctx:$}),l.$set(d);const p={};m&4&&(p.$$scope={dirty:m,ctx:$}),a.$set(p);const I={};m&4&&(I.$$scope={dirty:m,ctx:$}),i.$set(I)},i($){f||(v(t.$$.fragment,$),v(l.$$.fragment,$),v(a.$$.fragment,$),v(i.$$.fragment,$),f=!0)},o($){b(t.$$.fragment,$),b(l.$$.fragment,$),b(a.$$.fragment,$),b(i.$$.fragment,$),f=!1},d($){$&&(c(s),c(n),c(e)),K(t,$),K(l,$),K(a,$),K(i,$)}}}function Xt(r){let t,s;return t=new B({props:{bgImage:r[0]+"/disk_space_bg.jpg",bgImageOpacity:r[1],$$slots:{default:[Wt]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&1&&(a.bgImage=l[0]+"/disk_space_bg.jpg"),n&2&&(a.bgImageOpacity=l[1]),n&4&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function Yt(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class te extends at{constructor(t){super(),it(this,t,Yt,Xt,nt,{assetsDir:0,defaultBgOpacity:1})}}function ee(r){let t;return{c(){t=O(`Теперь рассмотрим ключевые принципы организации топиков в Kafka, что критически важно для
			построения эффективной и масштабируемой системы обмена сообщениями.`)},l(s){t=y(s,`Теперь рассмотрим ключевые принципы организации топиков в Kafka, что критически важно для
			построения эффективной и масштабируемой системы обмена сообщениями.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function se(r){let t,s='<div class="text-7xl font-bold">Организация топиков</div>',l,n,a;return n=new E({props:{$$slots:{default:[ee]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-fwleqm"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function le(r){let t;return{c(){t=O(`Выбор между одним или несколькими топиками - фундаментальное архитектурное решение. Один топик
			эффективен когда: - Данные однородны и имеют общий жизненный цикл - Сценарии потребления
			просты (один тип консьюмеров) - Требуются одинаковые настройки хранения и партиционирования
			Данные логически связаны и обрабатываются вместе Несколько топиков предпочтительнее когда: -
			Данные имеют разную природу и жизненные циклы - Существуют разные паттерны доступа и группы
			потребителей - Требования к хранению и производительности различаются - Необходимо логическое
			разделение по бизнес-доменам Этот выбор значительно влияет на гибкость, масштабируемость и
			управляемость системы в долгосрочной перспективе.`)},l(s){t=y(s,`Выбор между одним или несколькими топиками - фундаментальное архитектурное решение. Один топик
			эффективен когда: - Данные однородны и имеют общий жизненный цикл - Сценарии потребления
			просты (один тип консьюмеров) - Требуются одинаковые настройки хранения и партиционирования
			Данные логически связаны и обрабатываются вместе Несколько топиков предпочтительнее когда: -
			Данные имеют разную природу и жизненные циклы - Существуют разные паттерны доступа и группы
			потребителей - Требования к хранению и производительности различаются - Необходимо логическое
			разделение по бизнес-доменам Этот выбор значительно влияет на гибкость, масштабируемость и
			управляемость системы в долгосрочной перспективе.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function ne(r){let t,s='<div class="mb-12 text-5xl font-semibold">Один топик vs. несколько</div> <div class="flex w-full justify-center gap-12"><div class="w-2/5"><div class="mb-4 text-3xl"><strong>Один топик подходит для:</strong></div> <ul class="ml-8 space-y-3"><li class="text-2xl">Однородных данных с общим жизненным циклом</li> <li class="text-2xl">Простых сценариев потребления</li> <li class="text-2xl">Логически связанных данных</li></ul></div> <div class="w-2/5"><div class="mb-4 text-3xl"><strong>Несколько топиков лучше при:</strong></div> <ul class="ml-8 space-y-3"><li class="text-2xl">Разнородных данных</li> <li class="text-2xl">Различных шаблонах доступа</li> <li class="text-2xl">Разделении по доменам</li></ul></div></div>',l,n,a;return n=new E({props:{$$slots:{default:[le]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-x73693"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ae(r){let t;return{c(){t=O(`Доменная организация топиков основана на группировке по бизнес-областям, что отражает
			структуру вашей системы. Примеры именования в разных доменах: - Для заказов: orders.created,
			orders.updated, orders.cancelled - Для платежей: payments.initiated, payments.completed,
			payments.failed - Для логистики: logistics.shipment.created, logistics.delivery.completed
			Ключевые преимущества: - Доменная изоляция и независимость - Улучшенная наблюдаемость и
			мониторинг по бизнес-направлениям - Возможность настройки параметров под специфику каждого
			домена Основные сложности: - Увеличение количества топиков для управления и мониторинга -
			Расширение области конфигурирования и обслуживания - Потенциальные проблемы при кросс-доменных
			операциях`)},l(s){t=y(s,`Доменная организация топиков основана на группировке по бизнес-областям, что отражает
			структуру вашей системы. Примеры именования в разных доменах: - Для заказов: orders.created,
			orders.updated, orders.cancelled - Для платежей: payments.initiated, payments.completed,
			payments.failed - Для логистики: logistics.shipment.created, logistics.delivery.completed
			Ключевые преимущества: - Доменная изоляция и независимость - Улучшенная наблюдаемость и
			мониторинг по бизнес-направлениям - Возможность настройки параметров под специфику каждого
			домена Основные сложности: - Увеличение количества топиков для управления и мониторинга -
			Расширение области конфигурирования и обслуживания - Потенциальные проблемы при кросс-доменных
			операциях`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function ie(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Доменная организация топиков</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Примеры</strong>:
					<ul class="ml-8 mt-3 space-y-2"><li class="text-2xl">orders.created, orders.updated</li> <li class="text-2xl">payments.initiated, payments.completed</li> <li class="text-2xl">logistics.shipment.created</li></ul></li> <li class="mt-6 text-2xl"><strong>Плюсы</strong>: Независимость, наблюдаемость, гибкость</li> <li class="mt-6 text-2xl"><strong>Минусы</strong>: Управление количеством, сложность настройки</li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[ae]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-9b4vm5"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function re(r){let t;return{c(){t=O(`Практические рекомендации для эффективной организации топиков: Документация: - Создайте и
			поддерживайте централизованный каталог топиков - Документируйте назначение, схему данных,
			продюсеров и консьюмеров для каждого топика - Регулярно обновляйте документацию при изменениях
			Именование: - Следуйте единому стандарту - domain.entity.action (например,
			orders.item.created) - Используйте понятные и самодокументируемые имена - Избегайте
			сокращений, которые могут быть непонятны новым разработчикам Версионирование: - Планируйте
			изменения схем данных с самого начала - Используйте суффиксы (_v1, _v2) или встроенное
			версионирование схем (Avro/Protobuf) - Разработайте четкую стратегию совместимости (backward,
			forward, full) Планирование ресурсов: - Оценивайте ожидаемые объемы данных и пиковый трафик
			заранее - Правильно конфигурируйте партиционирование исходя из этих оценок - Учитывайте
			будущий рост при планировании Миграционная стратегия: - Разработайте план перехода при
			необходимости изменения топиков - Предусмотрите период параллельной записи в старые и новые
			топики - Минимизируйте влияние на работающие системы и пользователей`)},l(s){t=y(s,`Практические рекомендации для эффективной организации топиков: Документация: - Создайте и
			поддерживайте централизованный каталог топиков - Документируйте назначение, схему данных,
			продюсеров и консьюмеров для каждого топика - Регулярно обновляйте документацию при изменениях
			Именование: - Следуйте единому стандарту - domain.entity.action (например,
			orders.item.created) - Используйте понятные и самодокументируемые имена - Избегайте
			сокращений, которые могут быть непонятны новым разработчикам Версионирование: - Планируйте
			изменения схем данных с самого начала - Используйте суффиксы (_v1, _v2) или встроенное
			версионирование схем (Avro/Protobuf) - Разработайте четкую стратегию совместимости (backward,
			forward, full) Планирование ресурсов: - Оценивайте ожидаемые объемы данных и пиковый трафик
			заранее - Правильно конфигурируйте партиционирование исходя из этих оценок - Учитывайте
			будущий рост при планировании Миграционная стратегия: - Разработайте план перехода при
			необходимости изменения топиков - Предусмотрите период параллельной записи в старые и новые
			топики - Минимизируйте влияние на работающие системы и пользователей`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function fe(r){let t,s='<div class="mb-12 text-5xl font-semibold">Практические советы</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Документация</strong>: Каталог топиков</li> <li class="text-2xl"><strong>Именование</strong>: domain.entity.action</li> <li class="text-2xl"><strong>Версионирование</strong>: _v1, _v2 или схемы</li> <li class="text-2xl"><strong>Планирование</strong>: Оценка объёмов и трафика</li> <li class="text-2xl"><strong>Миграция</strong>: Стратегия перехода</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[re]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-13b7klj"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function $e(r){let t,s,l,n,a,e,i,f;return t=new B({props:{$$slots:{default:[se]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[ne]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[ie]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[fe]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment)},l($){w(t.$$.fragment,$),s=_($),w(l.$$.fragment,$),n=_($),w(a.$$.fragment,$),e=_($),w(i.$$.fragment,$)},m($,m){k(t,$,m),u($,s,m),k(l,$,m),u($,n,m),k(a,$,m),u($,e,m),k(i,$,m),f=!0},p($,m){const g={};m&4&&(g.$$scope={dirty:m,ctx:$}),t.$set(g);const d={};m&4&&(d.$$scope={dirty:m,ctx:$}),l.$set(d);const p={};m&4&&(p.$$scope={dirty:m,ctx:$}),a.$set(p);const I={};m&4&&(I.$$scope={dirty:m,ctx:$}),i.$set(I)},i($){f||(v(t.$$.fragment,$),v(l.$$.fragment,$),v(a.$$.fragment,$),v(i.$$.fragment,$),f=!0)},o($){b(t.$$.fragment,$),b(l.$$.fragment,$),b(a.$$.fragment,$),b(i.$$.fragment,$),f=!1},d($){$&&(c(s),c(n),c(e)),K(t,$),K(l,$),K(a,$),K(i,$)}}}function ce(r){let t,s;return t=new B({props:{bgImage:r[0]+"/kafka_topics_bg.jpg",bgImageOpacity:r[1],$$slots:{default:[$e]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&1&&(a.bgImage=l[0]+"/kafka_topics_bg.jpg"),n&2&&(a.bgImageOpacity=l[1]),n&4&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function oe(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class ue extends at{constructor(t){super(),it(this,t,oe,ce,nt,{assetsDir:0,defaultBgOpacity:1})}}function me(r){let t;return{c(){t=O(`В этом разделе мы рассмотрим ключевые настройки и параметры Apache Kafka, которые необходимо
			учитывать при проектировании и эксплуатации систем на базе этой платформы.`)},l(s){t=y(s,`В этом разделе мы рассмотрим ключевые настройки и параметры Apache Kafka, которые необходимо
			учитывать при проектировании и эксплуатации систем на базе этой платформы.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function pe(r){let t,s='<div class="text-7xl font-bold">Настройки</div>',l,n,a;return n=new E({props:{$$slots:{default:[me]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-l2jpte"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ge(r){let t=`
			Retention (политика хранения) в Kafka определяет, как долго или в каком объеме сообщения
			хранятся в топиках. Существует два основных типа политик retention: 
			1. Time-based retention (log.retention.hours):
				- Определяет, сколько времени сообщения хранятся в топике
				- По умолчанию: 168 часов (7 дней)
				- После истечения указанного периода, сообщения удаляются независимо от того, были ли они прочитаны
			2. Size-based retention (log.retention.bytes):
				- Определяет максимальный размер данных для партиции
				- Когда размер превышается, старые сообщения удаляются
				- По умолчанию: -1 (неограниченно, применяется только time-based retention)
			Политики могут применяться одновременно — сработает та, которая наступит раньше.
			Преимущества увеличения retention:
			- Возможность "возвращаться в прошлое" и перерабатывать исторические сообщения
			- Поддержка replay-сценариев для аналитики
			- Соответствие требованиям регуляторов (например, для финансового аудита)
			Причины для ограничения retention:
			- Экономия дискового пространства при быстром устаревании данных
			- Снижение затрат на инфраструктуру
			- Оптимизация производительности при ограниченных ресурсах
			При проектировании стоит анализировать бизнес-потребности и технические ограничения, чтобы найти оптимальный баланс между обоими типами политик.
			
			Преимущества увеличения retention:
				- Возможность "возвращаться в прошлое" и перерабатывать исторические сообщения
				- Поддержка replay-сценариев для аналитики
				- Соответствие требованиям регуляторов (например, для финансового аудита)
			Причины для ограничения retention:
				- Экономия дискового пространства при быстром устаревании данных
				- Снижение затрат на инфраструктуру
				- Оптимизация производительности при ограниченных ресурсах
			При проектировании стоит анализировать бизнес-потребности и технические ограничения, чтобы найти оптимальный баланс между обоими типами политик.
			между обоими типами политик.
			`,s;return{c(){s=O(t)},l(l){s=y(l,t)},m(l,n){u(l,s,n)},p:ct,d(l){l&&c(s)}}}function de(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Retention</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Два типа политик</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">По времени (log.retention.hours)</li> <li class="text-2xl">По размеру (log.retention.bytes)</li></ul></li> <li class="text-2xl"><strong>Увеличивать для</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">Аналитики исторических данных</li> <li class="text-2xl">Бизнес-требований по хранению</li></ul></li> <li class="text-2xl"><strong>Ограничивать при</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">Быстром устаревании данных</li> <li class="text-2xl">Ограниченных ресурсах</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[ge]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-1h6gkt3"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function xe(r){let t;return{c(){t=O(`Определение оптимального количества партиций — один из ключевых вопросов архитектуры Kafka.
			Основные принципы: 1. Количество партиций = требуемая пропускная способность / пропускная
			способность одной партиции 2. Партиций должно быть не меньше числа консьюмеров в группе для
			параллельной обработки Рекомендации: - Небольшая нагрузка: 1-3 партиции на топик - Типичные
			приложения: 10-30 партиций на топик - Высокая нагрузка: до 100 партиций (редкий случай)
			Ограничения: - Максимальное количество: 1000-2000 партиций на брокер (суммарно) - Слишком
			много партиций вызывает проблемы с ребалансировкой, нагрузку на Zookeeper, расход памяти
			Стратегия: сначала оптимизируйте обработку, затем увеличивайте число партиций. Увеличить
			легко, уменьшить почти невозможно.`)},l(s){t=y(s,`Определение оптимального количества партиций — один из ключевых вопросов архитектуры Kafka.
			Основные принципы: 1. Количество партиций = требуемая пропускная способность / пропускная
			способность одной партиции 2. Партиций должно быть не меньше числа консьюмеров в группе для
			параллельной обработки Рекомендации: - Небольшая нагрузка: 1-3 партиции на топик - Типичные
			приложения: 10-30 партиций на топик - Высокая нагрузка: до 100 партиций (редкий случай)
			Ограничения: - Максимальное количество: 1000-2000 партиций на брокер (суммарно) - Слишком
			много партиций вызывает проблемы с ребалансировкой, нагрузку на Zookeeper, расход памяти
			Стратегия: сначала оптимизируйте обработку, затем увеличивайте число партиций. Увеличить
			легко, уменьшить почти невозможно.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function _e(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Количество партиций</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Формула</strong>: (Требуемая пропускная способность) / (Пропускная способность
					одной партиции)</li> <li class="text-2xl"><strong>Партиции ≥ Консьюмеров</strong> в группе</li> <li class="text-2xl"><strong>Рекомендации</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">Начинать с 1-3 на топик для простых случаев</li> <li class="text-2xl">До 10-30 на топик для типичных нагрузок</li> <li class="text-2xl">Максимум ~1000-2000 на брокер в кластере</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[xe]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-m7nkky"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ve(r){let t;return{c(){t=O(`Партиции – фундаментальная единица параллелизма в Kafka, которая обеспечивает масштабируемость
			системы. Ключевые преимущества: - Горизонтальное масштабирование: чем больше партиций, тем
			больше консьюмеров могут читать данные параллельно - Упорядоченность: сообщения внутри одной
			партиции всегда доставляются в порядке их поступления - Локализация данных: при правильном
			выборе ключа (partition key) связанные данные группируются в одну партицию Проблемы при
			избыточном количестве партиций: - Увеличение нагрузки на ZooKeeper/Controller из-за метаданных
			- Замедление ребалансировки при добавлении/удалении консьюмеров или при сбоях - Фрагментация
			усложняет обработку связанных данных, если они оказываются в разных партициях Оптимальное
			количество партиций – результат компромисса между масштабируемостью и операционной сложностью.`)},l(s){t=y(s,`Партиции – фундаментальная единица параллелизма в Kafka, которая обеспечивает масштабируемость
			системы. Ключевые преимущества: - Горизонтальное масштабирование: чем больше партиций, тем
			больше консьюмеров могут читать данные параллельно - Упорядоченность: сообщения внутри одной
			партиции всегда доставляются в порядке их поступления - Локализация данных: при правильном
			выборе ключа (partition key) связанные данные группируются в одну партицию Проблемы при
			избыточном количестве партиций: - Увеличение нагрузки на ZooKeeper/Controller из-за метаданных
			- Замедление ребалансировки при добавлении/удалении консьюмеров или при сбоях - Фрагментация
			усложняет обработку связанных данных, если они оказываются в разных партициях Оптимальное
			количество партиций – результат компромисса между масштабируемостью и операционной сложностью.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function be(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Особенности партиций</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Параллельная обработка</strong></li> <li class="text-2xl"><strong>Сохранение порядка</strong> внутри партиции</li> <li class="text-2xl"><strong>Проблемы избытка</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">Overhead на метаданные</li> <li class="text-2xl">Медленная ребалансировка</li> <li class="text-2xl">Фрагментация данных</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[ve]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-17w6df9"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function he(r){let t;return{c(){t=O(`Выбор стратегии партиционирования существенно влияет на работу системы. Существует три
			основных подхода: 1. Round-robin (по умолчанию): - Сообщения распределяются равномерно между
			партициями - Максимально эффективное использование ресурсов - Не гарантирует порядок связанных
			сообщений 2. Key-based (по ключу): - Сообщения с одинаковым ключом попадают в одну партицию -
			Гарантирует порядок сообщений с одинаковым ключом - Может приводить к неравномерной нагрузке
			(skewed partitions) 3. Custom (кастомное партиционирование): - Реализация собственной логики
			распределения - Позволяет учитывать специфические бизнес-требования - Требует дополнительной
			разработки и тестирования Рекомендации по выбору: - Для финансовых транзакций или событий, где
			порядок критичен → Key-based - Для высоконагруженных систем с фокусом на пропускную
			способность → Round-robin - Для сложных сценариев с нестандартной группировкой → Custom`)},l(s){t=y(s,`Выбор стратегии партиционирования существенно влияет на работу системы. Существует три
			основных подхода: 1. Round-robin (по умолчанию): - Сообщения распределяются равномерно между
			партициями - Максимально эффективное использование ресурсов - Не гарантирует порядок связанных
			сообщений 2. Key-based (по ключу): - Сообщения с одинаковым ключом попадают в одну партицию -
			Гарантирует порядок сообщений с одинаковым ключом - Может приводить к неравномерной нагрузке
			(skewed partitions) 3. Custom (кастомное партиционирование): - Реализация собственной логики
			распределения - Позволяет учитывать специфические бизнес-требования - Требует дополнительной
			разработки и тестирования Рекомендации по выбору: - Для финансовых транзакций или событий, где
			порядок критичен → Key-based - Для высоконагруженных систем с фокусом на пропускную
			способность → Round-robin - Для сложных сценариев с нестандартной группировкой → Custom`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function we(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Стратегии партиционирования</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Round-robin</strong>: равномерное распределение</li> <li class="text-2xl"><strong>Key-based</strong>: одинаковые ключи → одна партиция</li> <li class="text-2xl"><strong>Custom</strong>: собственная логика</li> <li class="text-2xl"><strong>Выбор стратегии</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">Порядок событий → Key-based</li> <li class="text-2xl">Максимальная скорость → Round-robin</li> <li class="text-2xl">Специальная группировка → Custom</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[he]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-qmarb7"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ke(r){let t;return{c(){t=O(`Replication Factor (RF) – ключевой параметр надежности в Kafka, определяющий количество копий
			каждой партиции. Принцип работы: - Каждая партиция имеет одного лидера и несколько фолловеров
			(реплик) - При выходе из строя лидера один из фолловеров автоматически становится новым
			лидером - Чем выше RF, тем выше отказоустойчивость системы Рекомендации: - RF = 3 считается
			золотым стандартом для production-систем - RF = 2 может использоваться для менее критичных
			данных - RF = 1 не рекомендуется для production (отсутствие отказоустойчивости) Важно
			учитывать, что каждая дополнительная реплика линейно увеличивает требования к дисковому
			пространству. При RF = 3 весь объем данных хранится в трех копиях, что необходимо учитывать
			при планировании инфраструктуры.`)},l(s){t=y(s,`Replication Factor (RF) – ключевой параметр надежности в Kafka, определяющий количество копий
			каждой партиции. Принцип работы: - Каждая партиция имеет одного лидера и несколько фолловеров
			(реплик) - При выходе из строя лидера один из фолловеров автоматически становится новым
			лидером - Чем выше RF, тем выше отказоустойчивость системы Рекомендации: - RF = 3 считается
			золотым стандартом для production-систем - RF = 2 может использоваться для менее критичных
			данных - RF = 1 не рекомендуется для production (отсутствие отказоустойчивости) Важно
			учитывать, что каждая дополнительная реплика линейно увеличивает требования к дисковому
			пространству. При RF = 3 весь объем данных хранится в трех копиях, что необходимо учитывать
			при планировании инфраструктуры.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Ke(r){let t,s='<div class="mb-12 text-5xl font-semibold">Replication Factor</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Отказоустойчивость</strong>: лидер → фолловер</li> <li class="text-2xl"><strong>Оптимальное значение</strong>: RF = 3</li> <li class="text-2xl"><strong>Влияние на хранилище</strong>: объём данных × RF</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[ke]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-i7nuri"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ie(r){let t;return{c(){t=O(`Конфигурация репликации – критически важный аспект проектирования надежной системы на базе
			Kafka. Основные параметры: 1. Replication Factor (RF): - Определяет общее количество копий
			каждой партиции - RF=3 является стандартом для production-среды - Обеспечивает высокую
			доступность даже при выходе из строя двух брокеров 2. min.insync.replicas: - Указывает
			минимальное количество синхронизированных реплик для успешной записи при acks=all - Значение 2
			обычно используется с RF=3 - Защищает от потери данных при сбоях 3. Взаимодействие с acks: -
			При acks=all и min.insync.replicas=2: запись успешна только если сохранена минимум на двух
			репликах - Если количество доступных синхронизированных реплик меньше min.insync.replicas,
			продюсеры получат NotEnoughReplicas ошибку Надежная конфигурация для критически важных систем:
			- RF=3 + min.insync.replicas=2 + acks=all - Обеспечивает устойчивость к потере одного брокера
			без потери данных - Останавливает запись при потере двух брокеров вместо риска потери данных
			Этот набор настроек обеспечивает оптимальный баланс между надежностью и доступностью.`)},l(s){t=y(s,`Конфигурация репликации – критически важный аспект проектирования надежной системы на базе
			Kafka. Основные параметры: 1. Replication Factor (RF): - Определяет общее количество копий
			каждой партиции - RF=3 является стандартом для production-среды - Обеспечивает высокую
			доступность даже при выходе из строя двух брокеров 2. min.insync.replicas: - Указывает
			минимальное количество синхронизированных реплик для успешной записи при acks=all - Значение 2
			обычно используется с RF=3 - Защищает от потери данных при сбоях 3. Взаимодействие с acks: -
			При acks=all и min.insync.replicas=2: запись успешна только если сохранена минимум на двух
			репликах - Если количество доступных синхронизированных реплик меньше min.insync.replicas,
			продюсеры получат NotEnoughReplicas ошибку Надежная конфигурация для критически важных систем:
			- RF=3 + min.insync.replicas=2 + acks=all - Обеспечивает устойчивость к потере одного брокера
			без потери данных - Останавливает запись при потере двух брокеров вместо риска потери данных
			Этот набор настроек обеспечивает оптимальный баланс между надежностью и доступностью.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function De(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Конфигурация репликации</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Replication Factor</strong>: 3 (стандарт для production)</li> <li class="text-2xl"><strong>min.insync.replicas</strong>: минимум реплик для подтверждения</li> <li class="text-2xl"><strong>Надёжная конфигурация</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">RF=3 + min.insync.replicas=2 + acks=all</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[Ie]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-w9j76s"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ce(r){let t;return{c(){t=O(`Параметр acknowledgments (acks) определяет компромисс между надежностью и производительностью
			при записи данных. Три возможных значения: 1. acks=0: - Продюсер отправляет сообщение и не
			ждет подтверждений - Максимальная пропускная способность и минимальная задержка - Высокий риск
			потери данных при сбоях брокера - Подходит для логирования, метрик, где потеря части данных
			допустима 2. acks=1: - Продюсер ждет подтверждения только от лидера партиции - Разумный баланс
			между надежностью и производительностью - Возможна потеря данных при сбое лидера до репликации
			- Подходит для большинства бизнес-приложений 3. acks=all (или acks=-1): - Подтверждение от
			всех синхронизированных реплик (ISR) - Максимальная надежность, но ниже производительность -
			Минимальный риск потери данных - Необходим для финансовых транзакций, медицинских данных и
			других критичных систем В сочетании с настройкой min.insync.replicas можно точно
			контролировать гарантии надежности.`)},l(s){t=y(s,`Параметр acknowledgments (acks) определяет компромисс между надежностью и производительностью
			при записи данных. Три возможных значения: 1. acks=0: - Продюсер отправляет сообщение и не
			ждет подтверждений - Максимальная пропускная способность и минимальная задержка - Высокий риск
			потери данных при сбоях брокера - Подходит для логирования, метрик, где потеря части данных
			допустима 2. acks=1: - Продюсер ждет подтверждения только от лидера партиции - Разумный баланс
			между надежностью и производительностью - Возможна потеря данных при сбое лидера до репликации
			- Подходит для большинства бизнес-приложений 3. acks=all (или acks=-1): - Подтверждение от
			всех синхронизированных реплик (ISR) - Максимальная надежность, но ниже производительность -
			Минимальный риск потери данных - Необходим для финансовых транзакций, медицинских данных и
			других критичных систем В сочетании с настройкой min.insync.replicas можно точно
			контролировать гарантии надежности.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Te(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Acknowledgments (acks)</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Уровни</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl"><strong>acks=0</strong>: без ожидания (скорость &gt; надёжность)</li> <li class="text-2xl"><strong>acks=1</strong>: подтверждение от лидера (баланс)</li> <li class="text-2xl"><strong>acks=all</strong>: от всех in-sync реплик (надёжность &gt; скорость)</li></ul></li> <li class="text-2xl"><strong>Критичные системы</strong>: обычно acks=all</li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[Ce]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-xm7m16"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Re(r){let t;return{c(){t=O(`Настройки продюсера имеют значительное влияние на производительность и эффективность системы:
			1. Batch size: - Определяет максимальный размер пакета сообщений для отправки за один раз -
			Большие пакеты улучшают пропускную способность за счет меньшего количества сетевых вызовов -
			При увеличении batch size растет латентность отдельных сообщений - Рекомендуемые значения:
			16KB-128KB в зависимости от требований к латентности 2. linger.ms: - Время ожидания перед
			отправкой неполного пакета - 0 мс (по умолчанию): отправка сразу, без ожидания заполнения
			пакета - Увеличение значения уменьшает количество запросов, но повышает задержку - Типичные
			значения: 5-100 мс для оптимизации пропускной способности 3. Сжатие (compression): - gzip:
			высокая степень сжатия, но большая нагрузка на CPU - snappy: средняя степень сжатия, хорошая
			скорость, баланс между ресурсами и эффективность - lz4: быстрое сжатие/распаковка, хорошо для
			высоконагруженных систем - zstd: новый алгоритм с хорошим балансом между сжатием и
			производительностью Оптимальная стратегия: установить разумный batch size, добавить небольшой
			linger.ms (5-10 мс) и использовать сжатие snappy или lz4 для большинства систем.`)},l(s){t=y(s,`Настройки продюсера имеют значительное влияние на производительность и эффективность системы:
			1. Batch size: - Определяет максимальный размер пакета сообщений для отправки за один раз -
			Большие пакеты улучшают пропускную способность за счет меньшего количества сетевых вызовов -
			При увеличении batch size растет латентность отдельных сообщений - Рекомендуемые значения:
			16KB-128KB в зависимости от требований к латентности 2. linger.ms: - Время ожидания перед
			отправкой неполного пакета - 0 мс (по умолчанию): отправка сразу, без ожидания заполнения
			пакета - Увеличение значения уменьшает количество запросов, но повышает задержку - Типичные
			значения: 5-100 мс для оптимизации пропускной способности 3. Сжатие (compression): - gzip:
			высокая степень сжатия, но большая нагрузка на CPU - snappy: средняя степень сжатия, хорошая
			скорость, баланс между ресурсами и эффективность - lz4: быстрое сжатие/распаковка, хорошо для
			высоконагруженных систем - zstd: новый алгоритм с хорошим балансом между сжатием и
			производительностью Оптимальная стратегия: установить разумный batch size, добавить небольшой
			linger.ms (5-10 мс) и использовать сжатие snappy или lz4 для большинства систем.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Le(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Оптимизация продюсера</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Batch size</strong>: объединение сообщений</li> <li class="text-2xl"><strong>linger.ms</strong>: задержка для формирования пакета</li> <li class="text-2xl"><strong>Сжатие</strong>:
					<ul class="ml-8 mt-3 space-y-3"><li class="text-2xl">gzip: максимальное сжатие, высокое CPU</li> <li class="text-2xl">snappy/lz4: баланс сжатия и скорости</li> <li class="text-2xl">zstd: новый алгоритм, высокая эффективность</li></ul></li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[Re]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-6xq5mu"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function He(r){let t,s,l,n,a,e,i,f,$,m,g,d,p,I,S,A,H,j;return t=new B({props:{$$slots:{default:[pe]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[de]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[_e]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[be]},$$scope:{ctx:r}}}),$=new B({props:{$$slots:{default:[we]},$$scope:{ctx:r}}}),g=new B({props:{$$slots:{default:[Ke]},$$scope:{ctx:r}}}),p=new B({props:{$$slots:{default:[De]},$$scope:{ctx:r}}}),S=new B({props:{$$slots:{default:[Te]},$$scope:{ctx:r}}}),H=new B({props:{$$slots:{default:[Le]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment),f=x(),h($.$$.fragment),m=x(),h(g.$$.fragment),d=x(),h(p.$$.fragment),I=x(),h(S.$$.fragment),A=x(),h(H.$$.fragment)},l(o){w(t.$$.fragment,o),s=_(o),w(l.$$.fragment,o),n=_(o),w(a.$$.fragment,o),e=_(o),w(i.$$.fragment,o),f=_(o),w($.$$.fragment,o),m=_(o),w(g.$$.fragment,o),d=_(o),w(p.$$.fragment,o),I=_(o),w(S.$$.fragment,o),A=_(o),w(H.$$.fragment,o)},m(o,D){k(t,o,D),u(o,s,D),k(l,o,D),u(o,n,D),k(a,o,D),u(o,e,D),k(i,o,D),u(o,f,D),k($,o,D),u(o,m,D),k(g,o,D),u(o,d,D),k(p,o,D),u(o,I,D),k(S,o,D),u(o,A,D),k(H,o,D),j=!0},p(o,D){const N={};D&4&&(N.$$scope={dirty:D,ctx:o}),t.$set(N);const Q={};D&4&&(Q.$$scope={dirty:D,ctx:o}),l.$set(Q);const U={};D&4&&(U.$$scope={dirty:D,ctx:o}),a.$set(U);const W={};D&4&&(W.$$scope={dirty:D,ctx:o}),i.$set(W);const q={};D&4&&(q.$$scope={dirty:D,ctx:o}),$.$set(q);const tt={};D&4&&(tt.$$scope={dirty:D,ctx:o}),g.$set(tt);const G={};D&4&&(G.$$scope={dirty:D,ctx:o}),p.$set(G);const P={};D&4&&(P.$$scope={dirty:D,ctx:o}),S.$set(P);const Z={};D&4&&(Z.$$scope={dirty:D,ctx:o}),H.$set(Z)},i(o){j||(v(t.$$.fragment,o),v(l.$$.fragment,o),v(a.$$.fragment,o),v(i.$$.fragment,o),v($.$$.fragment,o),v(g.$$.fragment,o),v(p.$$.fragment,o),v(S.$$.fragment,o),v(H.$$.fragment,o),j=!0)},o(o){b(t.$$.fragment,o),b(l.$$.fragment,o),b(a.$$.fragment,o),b(i.$$.fragment,o),b($.$$.fragment,o),b(g.$$.fragment,o),b(p.$$.fragment,o),b(S.$$.fragment,o),b(H.$$.fragment,o),j=!1},d(o){o&&(c(s),c(n),c(e),c(f),c(m),c(d),c(I),c(A)),K(t,o),K(l,o),K(a,o),K(i,o),K($,o),K(g,o),K(p,o),K(S,o),K(H,o)}}}function Me(r){let t,s;return t=new B({props:{bgImage:r[0]+"/bg-topics-and-partitions.webp",bgImageOpacity:r[1],$$slots:{default:[He]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&1&&(a.bgImage=l[0]+"/bg-topics-and-partitions.webp"),n&2&&(a.bgImageOpacity=l[1]),n&4&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function Ve(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class Be extends at{constructor(t){super(),it(this,t,Ve,Me,nt,{assetsDir:0,defaultBgOpacity:1})}}function Oe(r){let t;return{c(){t=O(`Теперь поговорим о форматах сообщений в Kafka. Выбор формата критически влияет на
			производительность, гибкость и удобство работы с системой. Правильный формат поможет
			оптимизировать использование ресурсов и обеспечить эффективное взаимодействие между
			компонентами.`)},l(s){t=y(s,`Теперь поговорим о форматах сообщений в Kafka. Выбор формата критически влияет на
			производительность, гибкость и удобство работы с системой. Правильный формат поможет
			оптимизировать использование ресурсов и обеспечить эффективное взаимодействие между
			компонентами.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function ye(r){let t,s='<div class="text-7xl font-bold">Форматы сообщений</div>',l,n,a;return n=new E({props:{$$slots:{default:[Oe]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-q81l2u"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Fe(r){let t;return{c(){t=O(`При выборе формата сообщений нужно учитывать несколько факторов: JSON - текстовый формат с
			очевидными преимуществами: легко читается людьми, отлаживается и интегрируется практически с
			любой технологией. Однако у него есть существенные недостатки: значительно больший размер
			сообщений из-за текстового представления, отсутствие строгой типизации повышает риски
			несовместимости при изменениях, и относительно низкая производительность
			сериализации/десериализации. Бинарные форматы (Avro, Protobuf) предлагают противоположные
			характеристики: компактный размер данных экономит сетевой трафик и память, высокая
			производительность обработки, строгая типизация с контролем версий и поддержка эволюции схем.
			Но они сложнее в настройке, не читаемы человеком напрямую и требуют дополнительных
			инструментов для отладки. Выбор формата должен основываться на конкретных требованиях проекта:
			объемах данных, нагрузке, требованиях к совместимости и удобстве разработки.`)},l(s){t=y(s,`При выборе формата сообщений нужно учитывать несколько факторов: JSON - текстовый формат с
			очевидными преимуществами: легко читается людьми, отлаживается и интегрируется практически с
			любой технологией. Однако у него есть существенные недостатки: значительно больший размер
			сообщений из-за текстового представления, отсутствие строгой типизации повышает риски
			несовместимости при изменениях, и относительно низкая производительность
			сериализации/десериализации. Бинарные форматы (Avro, Protobuf) предлагают противоположные
			характеристики: компактный размер данных экономит сетевой трафик и память, высокая
			производительность обработки, строгая типизация с контролем версий и поддержка эволюции схем.
			Но они сложнее в настройке, не читаемы человеком напрямую и требуют дополнительных
			инструментов для отладки. Выбор формата должен основываться на конкретных требованиях проекта:
			объемах данных, нагрузке, требованиях к совместимости и удобстве разработки.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function je(r){let t,s='<div class="mb-12 text-5xl font-semibold">JSON vs Бинарные форматы</div> <div class="grid w-4/5 grid-cols-2 gap-8"><div><div class="mb-4 text-3xl"><strong>JSON</strong>:</div> <ul class="ml-8 space-y-2"><li class="text-2xl">✓ Читаемость</li> <li class="text-2xl">✓ Простая интеграция</li> <li class="text-2xl">✗ Больший размер</li> <li class="text-2xl">✗ Нет типизации</li></ul></div> <div><div class="mb-4 text-3xl"><strong>Avro/Protobuf</strong>:</div> <ul class="ml-8 space-y-2"><li class="text-2xl">✓ Компактность</li> <li class="text-2xl">✓ Производительность</li> <li class="text-2xl">✓ Контроль версий</li> <li class="text-2xl">✗ Сложнее в отладке</li></ul></div></div>',l,n,a;return n=new E({props:{$$slots:{default:[Fe]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-13rjk61"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ee(r){let t;return{c(){t=O(`Совместимость форматов сообщений — ключевой аспект проектирования систем на Kafka, особенно
			при длительном хранении данных и распределенной архитектуре. Обратная совместимость критична,
			когда в топиках остаются сообщения, созданные по старым схемам, или при обработке архивных
			данных. Она позволяет новым версиям приложений работать со старыми данными без необходимости
			их конвертации. Прямая совместимость особенно важна при поэтапном обновлении системы, когда
			некоторые компоненты уже генерируют сообщения по новой схеме, а другие еще используют старый
			код. Это обеспечивает плавную миграцию без простоев. Оба типа совместимости особенно хорошо
			поддерживаются бинарными форматами с системой схем, такими как Avro с Schema Registry. Эти
			инструменты позволяют автоматически проверять совместимость при обновлении схем.`)},l(s){t=y(s,`Совместимость форматов сообщений — ключевой аспект проектирования систем на Kafka, особенно
			при длительном хранении данных и распределенной архитектуре. Обратная совместимость критична,
			когда в топиках остаются сообщения, созданные по старым схемам, или при обработке архивных
			данных. Она позволяет новым версиям приложений работать со старыми данными без необходимости
			их конвертации. Прямая совместимость особенно важна при поэтапном обновлении системы, когда
			некоторые компоненты уже генерируют сообщения по новой схеме, а другие еще используют старый
			код. Это обеспечивает плавную миграцию без простоев. Оба типа совместимости особенно хорошо
			поддерживаются бинарными форматами с системой схем, такими как Avro с Schema Registry. Эти
			инструменты позволяют автоматически проверять совместимость при обновлении схем.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Se(r){let t,s='<div class="mb-12 text-5xl font-semibold">Совместимость сообщений</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Совместимость</strong> — работа с разными версиями сообщений</li> <li class="text-2xl"><strong>Обратная</strong>: новый код → старые сообщения</li> <li class="text-2xl"><strong>Прямая</strong>: старый код → новые сообщения</li></ul>',l,n,a;return n=new E({props:{$$slots:{default:[Ee]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-mlzg7j"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&4&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function Ae(r){let t;return{c(){t=O(`Рассмотрим конкретный пример обратной совместимости. В старой версии сообщение содержит только
			идентификатор пользователя и имя. Когда мы обновляем формат и добавляем поле email, новый код
			должен корректно обрабатывать старые сообщения. Это работает, поскольку все обязательные поля
			из старой версии присутствуют, а отсутствующее новое поле email может быть обработано
			значением по умолчанию (null, пустая строка) или пропущено в логике. Такой подход особенно
			удобен при итеративной разработке, когда постепенно добавляются новые атрибуты к существующим
			сущностям. Добавление необязательных полей — один из самых безопасных паттернов изменения
			схемы данных с точки зрения совместимости.`)},l(s){t=y(s,`Рассмотрим конкретный пример обратной совместимости. В старой версии сообщение содержит только
			идентификатор пользователя и имя. Когда мы обновляем формат и добавляем поле email, новый код
			должен корректно обрабатывать старые сообщения. Это работает, поскольку все обязательные поля
			из старой версии присутствуют, а отсутствующее новое поле email может быть обработано
			значением по умолчанию (null, пустая строка) или пропущено в логике. Такой подход особенно
			удобен при итеративной разработке, когда постепенно добавляются новые атрибуты к существующим
			сущностям. Добавление необязательных полей — один из самых безопасных паттернов изменения
			схемы данных с точки зрения совместимости.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Pe(r){let t,s,l="Обратная совместимость",n,a,e,i,f="Старое:",$,m,g=`{
  "user_id": 12345,
  "name": "Иван Петров"
}`,d,p,I,S='<div class="text-4xl">→</div>',A,H,j,o="Новое:",D,N,Q=`{
  "user_id": 12345,
  "name": "Иван Петров",
  "email": "ivan@example.com"
}`,U,W,q,tt='<div class="text-xl">✅ <strong>Добавление</strong> нового поля сохраняет обратную совместимость</div>',G,P,Z;return P=new E({props:{$$slots:{default:[Ae]},$$scope:{ctx:r}}}),{c(){t=T("div"),s=T("div"),s.textContent=l,n=x(),a=T("div"),e=T("div"),i=T("div"),i.textContent=f,$=x(),m=T("pre"),d=O(g),p=x(),I=T("div"),I.innerHTML=S,A=x(),H=T("div"),j=T("div"),j.textContent=o,D=x(),N=T("pre"),U=O(Q),W=x(),q=T("div"),q.innerHTML=tt,G=x(),h(P.$$.fragment),this.h()},l(M){t=R(M,"DIV",{class:!0});var F=J(t);s=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(s)!=="svelte-s6gkg4"&&(s.textContent=l),n=_(F),a=R(F,"DIV",{class:!0});var z=J(a);e=R(z,"DIV",{class:!0});var X=J(e);i=R(X,"DIV",{class:!0,"data-svelte-h":!0}),V(i)!=="svelte-94iw22"&&(i.textContent=f),$=_(X),m=R(X,"PRE",{class:!0});var et=J(m);d=y(et,g),et.forEach(c),X.forEach(c),p=_(z),I=R(z,"DIV",{class:!0,"data-svelte-h":!0}),V(I)!=="svelte-179jqoj"&&(I.innerHTML=S),A=_(z),H=R(z,"DIV",{class:!0});var Y=J(H);j=R(Y,"DIV",{class:!0,"data-svelte-h":!0}),V(j)!=="svelte-10pb23o"&&(j.textContent=o),D=_(Y),N=R(Y,"PRE",{class:!0});var st=J(N);U=y(st,Q),st.forEach(c),Y.forEach(c),z.forEach(c),W=_(F),q=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(q)!=="svelte-1celi3t"&&(q.innerHTML=tt),F.forEach(c),G=_(M),w(P.$$.fragment,M),this.h()},h(){C(s,"class","mb-8 text-5xl font-semibold"),C(i,"class","mb-2 text-xl font-semibold"),C(m,"class","text-lg text-green-300"),C(e,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(I,"class","flex w-[10%] items-center justify-center"),C(j,"class","mb-2 text-xl font-semibold"),C(N,"class","text-lg text-green-300"),C(H,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(a,"class","flex w-full justify-between px-8"),C(q,"class","mt-6 w-[90%] rounded-lg border-2 border-green-700 bg-green-900 p-3 text-white"),C(t,"class","flex flex-col items-center")},m(M,F){u(M,t,F),L(t,s),L(t,n),L(t,a),L(a,e),L(e,i),L(e,$),L(e,m),L(m,d),L(a,p),L(a,I),L(a,A),L(a,H),L(H,j),L(H,D),L(H,N),L(N,U),L(t,W),L(t,q),u(M,G,F),k(P,M,F),Z=!0},p(M,F){const z={};F&4&&(z.$$scope={dirty:F,ctx:M}),P.$set(z)},i(M){Z||(v(P.$$.fragment,M),Z=!0)},o(M){b(P.$$.fragment,M),Z=!1},d(M){M&&(c(t),c(G)),K(P,M)}}}function ze(r){let t;return{c(){t=O(`Прямая совместимость обеспечивает работоспособность старого кода с новыми версиями сообщений.
			В нашем примере мы добавляем новый объект metadata с дополнительной информацией. Ключевой
			момент здесь в том, что старый код должен безопасно игнорировать неизвестные поля. Большинство
			современных парсеров JSON по умолчанию пропускают неизвестные поля при десериализации в
			объекты. В строго типизированных языках это обеспечивается маппингом только существующих
			свойств. В динамических языках дополнительные поля просто добавляются к объекту, не вызывая
			ошибок. Такой подход позволяет постепенно обогащать сообщения новыми метаданными и свойствами,
			не требуя одновременного обновления всех компонентов системы. Это особенно ценно в
			микросервисной архитектуре, где разные команды могут поддерживать различные сервисы.`)},l(s){t=y(s,`Прямая совместимость обеспечивает работоспособность старого кода с новыми версиями сообщений.
			В нашем примере мы добавляем новый объект metadata с дополнительной информацией. Ключевой
			момент здесь в том, что старый код должен безопасно игнорировать неизвестные поля. Большинство
			современных парсеров JSON по умолчанию пропускают неизвестные поля при десериализации в
			объекты. В строго типизированных языках это обеспечивается маппингом только существующих
			свойств. В динамических языках дополнительные поля просто добавляются к объекту, не вызывая
			ошибок. Такой подход позволяет постепенно обогащать сообщения новыми метаданными и свойствами,
			не требуя одновременного обновления всех компонентов системы. Это особенно ценно в
			микросервисной архитектуре, где разные команды могут поддерживать различные сервисы.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Ne(r){let t,s,l="Прямая совместимость",n,a,e,i,f="Старое:",$,m,g=`{
  "user": {
    "id": 12345,
    "name": "Иван"
  },
  "status": "active"
}`,d,p,I,S='<div class="text-4xl">→</div>',A,H,j,o="Новое:",D,N,Q=`{
  "user": {
    "id": 12345,
    "name": "Иван"
  },
  "status": "active",
  "metadata": {
    "created_at": "2023-05-10"
  }
}`,U,W,q,tt='<div class="text-xl">✅ <strong>Новые объекты</strong> игнорируются старым кодом</div>',G,P,Z;return P=new E({props:{$$slots:{default:[ze]},$$scope:{ctx:r}}}),{c(){t=T("div"),s=T("div"),s.textContent=l,n=x(),a=T("div"),e=T("div"),i=T("div"),i.textContent=f,$=x(),m=T("pre"),d=O(g),p=x(),I=T("div"),I.innerHTML=S,A=x(),H=T("div"),j=T("div"),j.textContent=o,D=x(),N=T("pre"),U=O(Q),W=x(),q=T("div"),q.innerHTML=tt,G=x(),h(P.$$.fragment),this.h()},l(M){t=R(M,"DIV",{class:!0});var F=J(t);s=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(s)!=="svelte-1q6ggws"&&(s.textContent=l),n=_(F),a=R(F,"DIV",{class:!0});var z=J(a);e=R(z,"DIV",{class:!0});var X=J(e);i=R(X,"DIV",{class:!0,"data-svelte-h":!0}),V(i)!=="svelte-94iw22"&&(i.textContent=f),$=_(X),m=R(X,"PRE",{class:!0});var et=J(m);d=y(et,g),et.forEach(c),X.forEach(c),p=_(z),I=R(z,"DIV",{class:!0,"data-svelte-h":!0}),V(I)!=="svelte-179jqoj"&&(I.innerHTML=S),A=_(z),H=R(z,"DIV",{class:!0});var Y=J(H);j=R(Y,"DIV",{class:!0,"data-svelte-h":!0}),V(j)!=="svelte-10pb23o"&&(j.textContent=o),D=_(Y),N=R(Y,"PRE",{class:!0});var st=J(N);U=y(st,Q),st.forEach(c),Y.forEach(c),z.forEach(c),W=_(F),q=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(q)!=="svelte-f5xara"&&(q.innerHTML=tt),F.forEach(c),G=_(M),w(P.$$.fragment,M),this.h()},h(){C(s,"class","mb-8 text-5xl font-semibold"),C(i,"class","mb-2 text-xl font-semibold"),C(m,"class","text-lg text-green-300"),C(e,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(I,"class","flex w-[10%] items-center justify-center"),C(j,"class","mb-2 text-xl font-semibold"),C(N,"class","text-lg text-green-300"),C(H,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(a,"class","flex w-full justify-between px-8"),C(q,"class","mt-6 w-[90%] rounded-lg border-2 border-green-700 bg-green-900 p-3 text-white"),C(t,"class","flex flex-col items-center")},m(M,F){u(M,t,F),L(t,s),L(t,n),L(t,a),L(a,e),L(e,i),L(e,$),L(e,m),L(m,d),L(a,p),L(a,I),L(a,A),L(a,H),L(H,j),L(H,D),L(H,N),L(N,U),L(t,W),L(t,q),u(M,G,F),k(P,M,F),Z=!0},p(M,F){const z={};F&4&&(z.$$scope={dirty:F,ctx:M}),P.$set(z)},i(M){Z||(v(P.$$.fragment,M),Z=!0)},o(M){b(P.$$.fragment,M),Z=!1},d(M){M&&(c(t),c(G)),K(P,M)}}}function qe(r){let t;return{c(){t=O(`Некоторые изменения в структуре сообщений нарушают и прямую, и обратную совместимость. В
			данном примере мы перенесли поле phone внутрь нового объекта contact. Это классический пример
			несовместимого изменения. Старый код ищет поле phone в корне объекта, но не найдет его в новой
			структуре. Аналогично, новый код будет искать объект contact в старых сообщениях, который там
			отсутствует. Подобные изменения требуют особого подхода: 1. Синхронное обновление всех
			компонентов системы (что часто невозможно в распределенных системах) 2. Использование системы
			версионирования сообщений (добавление поля version и обработка разных версий) 3. Промежуточный
			этап с поддержкой обоих форматов (дублирование данных в старом и новом расположении) 4.
			Использование миграционных скриптов для обновления хранящихся данных Лучше избегать таких
			структурных изменений, особенно в системах с долгосрочным хранением данных. Если они
			необходимы, следует тщательно планировать миграцию с учетом всех потребителей данных.`)},l(s){t=y(s,`Некоторые изменения в структуре сообщений нарушают и прямую, и обратную совместимость. В
			данном примере мы перенесли поле phone внутрь нового объекта contact. Это классический пример
			несовместимого изменения. Старый код ищет поле phone в корне объекта, но не найдет его в новой
			структуре. Аналогично, новый код будет искать объект contact в старых сообщениях, который там
			отсутствует. Подобные изменения требуют особого подхода: 1. Синхронное обновление всех
			компонентов системы (что часто невозможно в распределенных системах) 2. Использование системы
			версионирования сообщений (добавление поля version и обработка разных версий) 3. Промежуточный
			этап с поддержкой обоих форматов (дублирование данных в старом и новом расположении) 4.
			Использование миграционных скриптов для обновления хранящихся данных Лучше избегать таких
			структурных изменений, особенно в системах с долгосрочным хранением данных. Если они
			необходимы, следует тщательно планировать миграцию с учетом всех потребителей данных.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function Je(r){let t,s,l="Несовместимые изменения",n,a,e,i,f="Старое:",$,m,g=`{
  "customer_id": 42,
  "phone": "79991234567"
}`,d,p,I,S='<div class="text-4xl">→</div>',A,H,j,o="Новое:",D,N,Q=`{
  "customer_id": 42,
  "contact": {
    "phone": "79991234567"
  }
}`,U,W,q,tt='<div class="text-xl">❌ <strong>Перемещение полей</strong> нарушает совместимость</div>',G,P,Z;return P=new E({props:{$$slots:{default:[qe]},$$scope:{ctx:r}}}),{c(){t=T("div"),s=T("div"),s.textContent=l,n=x(),a=T("div"),e=T("div"),i=T("div"),i.textContent=f,$=x(),m=T("pre"),d=O(g),p=x(),I=T("div"),I.innerHTML=S,A=x(),H=T("div"),j=T("div"),j.textContent=o,D=x(),N=T("pre"),U=O(Q),W=x(),q=T("div"),q.innerHTML=tt,G=x(),h(P.$$.fragment),this.h()},l(M){t=R(M,"DIV",{class:!0});var F=J(t);s=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(s)!=="svelte-13hfyme"&&(s.textContent=l),n=_(F),a=R(F,"DIV",{class:!0});var z=J(a);e=R(z,"DIV",{class:!0});var X=J(e);i=R(X,"DIV",{class:!0,"data-svelte-h":!0}),V(i)!=="svelte-94iw22"&&(i.textContent=f),$=_(X),m=R(X,"PRE",{class:!0});var et=J(m);d=y(et,g),et.forEach(c),X.forEach(c),p=_(z),I=R(z,"DIV",{class:!0,"data-svelte-h":!0}),V(I)!=="svelte-179jqoj"&&(I.innerHTML=S),A=_(z),H=R(z,"DIV",{class:!0});var Y=J(H);j=R(Y,"DIV",{class:!0,"data-svelte-h":!0}),V(j)!=="svelte-10pb23o"&&(j.textContent=o),D=_(Y),N=R(Y,"PRE",{class:!0});var st=J(N);U=y(st,Q),st.forEach(c),Y.forEach(c),z.forEach(c),W=_(F),q=R(F,"DIV",{class:!0,"data-svelte-h":!0}),V(q)!=="svelte-nwbinn"&&(q.innerHTML=tt),F.forEach(c),G=_(M),w(P.$$.fragment,M),this.h()},h(){C(s,"class","mb-8 text-5xl font-semibold"),C(i,"class","mb-2 text-xl font-semibold"),C(m,"class","text-lg text-green-300"),C(e,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(I,"class","flex w-[10%] items-center justify-center"),C(j,"class","mb-2 text-xl font-semibold"),C(N,"class","text-lg text-green-300"),C(H,"class","w-[500px] rounded-lg border-2 border-gray-700 bg-gray-800 p-4"),C(a,"class","flex w-full justify-between px-8"),C(q,"class","mt-6 w-[90%] rounded-lg border-2 border-red-700 bg-red-900 p-3 text-white"),C(t,"class","flex flex-col items-center")},m(M,F){u(M,t,F),L(t,s),L(t,n),L(t,a),L(a,e),L(e,i),L(e,$),L(e,m),L(m,d),L(a,p),L(a,I),L(a,A),L(a,H),L(H,j),L(H,D),L(H,N),L(N,U),L(t,W),L(t,q),u(M,G,F),k(P,M,F),Z=!0},p(M,F){const z={};F&4&&(z.$$scope={dirty:F,ctx:M}),P.$set(z)},i(M){Z||(v(P.$$.fragment,M),Z=!0)},o(M){b(P.$$.fragment,M),Z=!1},d(M){M&&(c(t),c(G)),K(P,M)}}}function Ue(r){let t,s,l,n,a,e,i,f,$,m,g,d;return t=new B({props:{bgImage:r[0]+"/bg-message-structure.webp",bgImageOpacity:r[1],$$slots:{default:[ye]},$$scope:{ctx:r}}}),l=new B({props:{bgImage:r[0]+"/bg-message-structure.webp",bgImageOpacity:r[1],$$slots:{default:[je]},$$scope:{ctx:r}}}),a=new B({props:{$$slots:{default:[Se]},$$scope:{ctx:r}}}),i=new B({props:{$$slots:{default:[Pe]},$$scope:{ctx:r}}}),$=new B({props:{$$slots:{default:[Ne]},$$scope:{ctx:r}}}),g=new B({props:{$$slots:{default:[Je]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment),f=x(),h($.$$.fragment),m=x(),h(g.$$.fragment)},l(p){w(t.$$.fragment,p),s=_(p),w(l.$$.fragment,p),n=_(p),w(a.$$.fragment,p),e=_(p),w(i.$$.fragment,p),f=_(p),w($.$$.fragment,p),m=_(p),w(g.$$.fragment,p)},m(p,I){k(t,p,I),u(p,s,I),k(l,p,I),u(p,n,I),k(a,p,I),u(p,e,I),k(i,p,I),u(p,f,I),k($,p,I),u(p,m,I),k(g,p,I),d=!0},p(p,I){const S={};I&1&&(S.bgImage=p[0]+"/bg-message-structure.webp"),I&2&&(S.bgImageOpacity=p[1]),I&4&&(S.$$scope={dirty:I,ctx:p}),t.$set(S);const A={};I&1&&(A.bgImage=p[0]+"/bg-message-structure.webp"),I&2&&(A.bgImageOpacity=p[1]),I&4&&(A.$$scope={dirty:I,ctx:p}),l.$set(A);const H={};I&4&&(H.$$scope={dirty:I,ctx:p}),a.$set(H);const j={};I&4&&(j.$$scope={dirty:I,ctx:p}),i.$set(j);const o={};I&4&&(o.$$scope={dirty:I,ctx:p}),$.$set(o);const D={};I&4&&(D.$$scope={dirty:I,ctx:p}),g.$set(D)},i(p){d||(v(t.$$.fragment,p),v(l.$$.fragment,p),v(a.$$.fragment,p),v(i.$$.fragment,p),v($.$$.fragment,p),v(g.$$.fragment,p),d=!0)},o(p){b(t.$$.fragment,p),b(l.$$.fragment,p),b(a.$$.fragment,p),b(i.$$.fragment,p),b($.$$.fragment,p),b(g.$$.fragment,p),d=!1},d(p){p&&(c(s),c(n),c(e),c(f),c(m)),K(t,p),K(l,p),K(a,p),K(i,p),K($,p),K(g,p)}}}function Ge(r){let t,s;return t=new B({props:{$$slots:{default:[Ue]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&7&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}function Ze(r,t,s){let{assetsDir:l=""}=t,{defaultBgOpacity:n="0.5"}=t;return r.$$set=a=>{"assetsDir"in a&&s(0,l=a.assetsDir),"defaultBgOpacity"in a&&s(1,n=a.defaultBgOpacity)},[l,n]}class Qe extends at{constructor(t){super(),it(this,t,Ze,Ge,nt,{assetsDir:0,defaultBgOpacity:1})}}function ft(r,t,s){const l=r.slice();return l[1]=t[s],l}function $t(r){let t,s,l,n,a=r[1].title+"",e,i,f;return s=new gt({props:{network:r[1].network,fgColor:"#111111",bgColor:"#eeeeee",width:"32",height:"32"}}),{c(){t=T("a"),h(s.$$.fragment),l=x(),n=T("span"),e=O(a),i=x(),this.h()},l($){t=R($,"A",{class:!0,href:!0,target:!0});var m=J(t);w(s.$$.fragment,m),l=_(m),n=R(m,"SPAN",{class:!0});var g=J(n);e=y(g,a),g.forEach(c),i=_(m),m.forEach(c),this.h()},h(){C(n,"class","!my-auto text-base"),C(t,"class","flex items-start gap-4"),C(t,"href",r[1].url),C(t,"target","_blank")},m($,m){u($,t,m),k(s,t,null),L(t,l),L(t,n),L(n,e),L(t,i),f=!0},p:ct,i($){f||(v(s.$$.fragment,$),f=!0)},o($){b(s.$$.fragment,$),f=!1},d($){$&&c(t),K(s)}}}function We(r){let t,s,l='Алексей Мальцев, <a class="!text-orange-400" href="https://www.maltsev.space/" target="_blank">maltsev.space</a>',n,a,e,i=rt(r[0]),f=[];for(let m=0;m<i.length;m+=1)f[m]=$t(ft(r,i,m));const $=m=>b(f[m],1,1,()=>{f[m]=null});return{c(){t=T("div"),s=T("div"),s.innerHTML=l,n=x(),a=T("div");for(let m=0;m<f.length;m+=1)f[m].c();this.h()},l(m){t=R(m,"DIV",{class:!0});var g=J(t);s=R(g,"DIV",{class:!0,"data-svelte-h":!0}),V(s)!=="svelte-105cun2"&&(s.innerHTML=l),n=_(g),a=R(g,"DIV",{class:!0});var d=J(a);for(let p=0;p<f.length;p+=1)f[p].l(d);d.forEach(c),g.forEach(c),this.h()},h(){C(s,"class","mt-10 text-lg"),C(a,"class","mt-4 flex flex-col items-start gap-6"),C(t,"class","flex flex-col items-center")},m(m,g){u(m,t,g),L(t,s),L(t,n),L(t,a);for(let d=0;d<f.length;d+=1)f[d]&&f[d].m(a,null);e=!0},p(m,[g]){if(g&1){i=rt(m[0]);let d;for(d=0;d<i.length;d+=1){const p=ft(m,i,d);f[d]?(f[d].p(p,g),v(f[d],1)):(f[d]=$t(p),f[d].c(),v(f[d],1),f[d].m(a,null))}for(ot(),d=i.length;d<f.length;d+=1)$(d);ut()}},i(m){if(!e){for(let g=0;g<i.length;g+=1)v(f[g]);e=!0}},o(m){f=f.filter(Boolean);for(let g=0;g<f.length;g+=1)b(f[g]);e=!1},d(m){m&&c(t),mt(f,m)}}}function Xe(r){return[[{network:"github",title:"github.com/AxelUser",url:"https://github.com/AxelUser"},{network:"telegram",title:"t.me/AxelUser",url:"https://t.me/AxelUser"}]]}class Ye extends at{constructor(t){super(),it(this,t,Xe,We,nt,{})}}function ts(r){let t;return{c(){t=O(`Всем привет! Рад вас видеть на вебинаре «Проектируем Apache Kafka с умом». Сегодня мы
			рассмотрим пять ключевых аспектов проектирования систем на базе Apache Kafka: архитектуру и
			основные компоненты, методы расчета объёма хранилища и оценки производительности, подходы к
			организации топиков и стратегии партиционирования, форматы сообщений и принципы совместимости,
			а также настройки, влияющие на надёжность и производительность системы. Весь материал
			ориентирован на практическое применение и сопровождается конкретными рекомендациями.`)},l(s){t=y(s,`Всем привет! Рад вас видеть на вебинаре «Проектируем Apache Kafka с умом». Сегодня мы
			рассмотрим пять ключевых аспектов проектирования систем на базе Apache Kafka: архитектуру и
			основные компоненты, методы расчета объёма хранилища и оценки производительности, подходы к
			организации топиков и стратегии партиционирования, форматы сообщений и принципы совместимости,
			а также настройки, влияющие на надёжность и производительность системы. Весь материал
			ориентирован на практическое применение и сопровождается конкретными рекомендациями.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function es(r){let t,s='<div class="mb-16 text-7xl font-bold">Проектируем Apache Kafka с умом</div> <div class="mb-10"><ol class="space-y-5"><li class="text-2xl">Архитектура и основные компоненты</li> <li class="text-2xl">Расчёт объёма хранилища и производительности</li> <li class="text-2xl">Организация топиков и партиционирование</li> <li class="text-2xl">Форматы сообщений и совместимость</li> <li class="text-2xl">Настройки надёжности и производительности</li></ol></div>',l,n,a;return n=new E({props:{$$slots:{default:[ts]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-18soyd"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full flex-col items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&2&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ss(r){let t;return{c(){t=O("Подведем итоги и обобщим ключевые моменты проектирования Apache Kafka.")},l(s){t=y(s,"Подведем итоги и обобщим ключевые моменты проектирования Apache Kafka.")},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function ls(r){let t,s='<div class="text-7xl font-bold">Заключение</div>',l,n,a;return n=new E({props:{$$slots:{default:[ss]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-u4h5m3"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex h-full items-center justify-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&2&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function ns(r){let t;return{c(){t=O(`Подводя итоги, хочу выделить пять ключевых принципов проектирования Kafka. Во-первых, всегда
				тщательно оценивайте объём хранилища на основе количества сообщений, их размера, времени
				хранения и репликации. Во-вторых, грамотно организуйте топики, разделяя их по
				бизнес-доменам. В-третьих, выбирайте подходящий формат данных – JSON для простоты или
				бинарные форматы для производительности. В-четвёртых, правильно настраивайте
				партиционирование, учитывая порядок сообщений и требования к параллельной обработке. И
				наконец, настраивайте уровень надёжности в соответствии с критичностью данных в вашей
				системе. Все эти аспекты взаимосвязаны, и их баланс определяет успешность вашего решения на
				базе Kafka.`)},l(s){t=y(s,`Подводя итоги, хочу выделить пять ключевых принципов проектирования Kafka. Во-первых, всегда
				тщательно оценивайте объём хранилища на основе количества сообщений, их размера, времени
				хранения и репликации. Во-вторых, грамотно организуйте топики, разделяя их по
				бизнес-доменам. В-третьих, выбирайте подходящий формат данных – JSON для простоты или
				бинарные форматы для производительности. В-четвёртых, правильно настраивайте
				партиционирование, учитывая порядок сообщений и требования к параллельной обработке. И
				наконец, настраивайте уровень надёжности в соответствии с критичностью данных в вашей
				системе. Все эти аспекты взаимосвязаны, и их баланс определяет успешность вашего решения на
				базе Kafka.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function as(r){let t,s=`<div class="mb-12 text-5xl font-semibold">Ключевые принципы проектирования Kafka</div> <ul class="w-4/5 space-y-6"><li class="text-2xl"><strong>Архитектура</strong>: Оптимизируйте брокеры, их количество и ресурсы с учётом
						отказоустойчивости</li> <li class="text-2xl"><strong>Объём хранилища</strong>: Рассчитывайте по формуле EPS × размер сообщения ×
						retention × RF</li> <li class="text-2xl"><strong>Организация топиков</strong>: Структурируйте по бизнес-доменам с понятной схемой
						именования</li> <li class="text-2xl"><strong>Форматы сообщений</strong>: Обеспечивайте совместимость при эволюции схем данных</li> <li class="text-2xl"><strong>Настройки</strong>: Балансируйте надёжность (acks, RF) и производительность
						(партиции, batch size)</li></ul>`,l,n,a;return n=new E({props:{$$slots:{default:[ns]},$$scope:{ctx:r}}}),{c(){t=T("div"),t.innerHTML=s,l=x(),h(n.$$.fragment),this.h()},l(e){t=R(e,"DIV",{class:!0,"data-svelte-h":!0}),V(t)!=="svelte-v30z9s"&&(t.innerHTML=s),l=_(e),w(n.$$.fragment,e),this.h()},h(){C(t,"class","flex flex-col items-center")},m(e,i){u(e,t,i),u(e,l,i),k(n,e,i),a=!0},p(e,i){const f={};i&2&&(f.$$scope={dirty:i,ctx:e}),n.$set(f)},i(e){a||(v(n.$$.fragment,e),a=!0)},o(e){b(n.$$.fragment,e),a=!1},d(e){e&&(c(t),c(l)),K(n,e)}}}function is(r){let t,s,l,n;return t=new B({props:{$$slots:{default:[ls]},$$scope:{ctx:r}}}),l=new B({props:{$$slots:{default:[as]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment)},l(a){w(t.$$.fragment,a),s=_(a),w(l.$$.fragment,a)},m(a,e){k(t,a,e),u(a,s,e),k(l,a,e),n=!0},p(a,e){const i={};e&2&&(i.$$scope={dirty:e,ctx:a}),t.$set(i);const f={};e&2&&(f.$$scope={dirty:e,ctx:a}),l.$set(f)},i(a){n||(v(t.$$.fragment,a),v(l.$$.fragment,a),n=!0)},o(a){b(t.$$.fragment,a),b(l.$$.fragment,a),n=!1},d(a){a&&c(s),K(t,a),K(l,a)}}}function rs(r){let t;return{c(){t=O(`Спасибо за внимание! Надеюсь, что информация была полезной и поможет вам в проектировании
			систем на базе Apache Kafka. Сейчас я готов ответить на ваши вопросы. Если у вас появятся
			вопросы позже, вы можете связаться со мной по указанным контактам. Также на моем сайте вы
			найдете дополнительные материалы по Kafka, включая примеры конфигураций и шаблоны
			проектирования.`)},l(s){t=y(s,`Спасибо за внимание! Надеюсь, что информация была полезной и поможет вам в проектировании
			систем на базе Apache Kafka. Сейчас я готов ответить на ваши вопросы. Если у вас появятся
			вопросы позже, вы можете связаться со мной по указанным контактам. Также на моем сайте вы
			найдете дополнительные материалы по Kafka, включая примеры конфигураций и шаблоны
			проектирования.`)},m(s,l){u(s,t,l)},d(s){s&&c(t)}}}function fs(r){let t,s,l="Спасибо за внимание!",n,a,e="Буду рад ответить на ваши вопросы!",i,f,$,m,g;return f=new Ye({}),m=new E({props:{$$slots:{default:[rs]},$$scope:{ctx:r}}}),{c(){t=T("div"),s=T("div"),s.textContent=l,n=x(),a=T("div"),a.textContent=e,i=x(),h(f.$$.fragment),$=x(),h(m.$$.fragment),this.h()},l(d){t=R(d,"DIV",{class:!0});var p=J(t);s=R(p,"DIV",{class:!0,"data-svelte-h":!0}),V(s)!=="svelte-1utq3qx"&&(s.textContent=l),n=_(p),a=R(p,"DIV",{class:!0,"data-svelte-h":!0}),V(a)!=="svelte-37vcmo"&&(a.textContent=e),i=_(p),w(f.$$.fragment,p),p.forEach(c),$=_(d),w(m.$$.fragment,d),this.h()},h(){C(s,"class","mb-16 text-7xl font-bold"),C(a,"class","mb-12 text-3xl"),C(t,"class","flex h-full flex-col items-center justify-center")},m(d,p){u(d,t,p),L(t,s),L(t,n),L(t,a),L(t,i),k(f,t,null),u(d,$,p),k(m,d,p),g=!0},p(d,p){const I={};p&2&&(I.$$scope={dirty:p,ctx:d}),m.$set(I)},i(d){g||(v(f.$$.fragment,d),v(m.$$.fragment,d),g=!0)},o(d){b(f.$$.fragment,d),b(m.$$.fragment,d),g=!1},d(d){d&&(c(t),c($)),K(f),K(m,d)}}}function $s(r){let t,s,l,n,a,e,i,f,$,m,g,d,p,I,S,A,H,j;return t=new B({props:{bgImage:r[0]+"/title_bg.jpg",bgImageOpacity:lt,$$slots:{default:[es]},$$scope:{ctx:r}}}),l=new Pt({props:{assetsDir:r[0],defaultBgOpacity:lt}}),a=new Tt({props:{assetsDir:r[0],defaultBgOpacity:lt}}),i=new te({props:{assetsDir:r[0],defaultBgOpacity:lt}}),$=new ue({props:{assetsDir:r[0],defaultBgOpacity:lt}}),g=new Qe({props:{assetsDir:r[0],defaultBgOpacity:lt}}),p=new Be({props:{assetsDir:r[0],defaultBgOpacity:lt}}),S=new B({props:{bgImage:r[0]+"/title_bg.jpg",bgImageOpacity:lt,$$slots:{default:[is]},$$scope:{ctx:r}}}),H=new B({props:{$$slots:{default:[fs]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment),s=x(),h(l.$$.fragment),n=x(),h(a.$$.fragment),e=x(),h(i.$$.fragment),f=x(),h($.$$.fragment),m=x(),h(g.$$.fragment),d=x(),h(p.$$.fragment),I=x(),h(S.$$.fragment),A=x(),h(H.$$.fragment)},l(o){w(t.$$.fragment,o),s=_(o),w(l.$$.fragment,o),n=_(o),w(a.$$.fragment,o),e=_(o),w(i.$$.fragment,o),f=_(o),w($.$$.fragment,o),m=_(o),w(g.$$.fragment,o),d=_(o),w(p.$$.fragment,o),I=_(o),w(S.$$.fragment,o),A=_(o),w(H.$$.fragment,o)},m(o,D){k(t,o,D),u(o,s,D),k(l,o,D),u(o,n,D),k(a,o,D),u(o,e,D),k(i,o,D),u(o,f,D),k($,o,D),u(o,m,D),k(g,o,D),u(o,d,D),k(p,o,D),u(o,I,D),k(S,o,D),u(o,A,D),k(H,o,D),j=!0},p(o,D){const N={};D&2&&(N.$$scope={dirty:D,ctx:o}),t.$set(N);const Q={};D&2&&(Q.$$scope={dirty:D,ctx:o}),S.$set(Q);const U={};D&2&&(U.$$scope={dirty:D,ctx:o}),H.$set(U)},i(o){j||(v(t.$$.fragment,o),v(l.$$.fragment,o),v(a.$$.fragment,o),v(i.$$.fragment,o),v($.$$.fragment,o),v(g.$$.fragment,o),v(p.$$.fragment,o),v(S.$$.fragment,o),v(H.$$.fragment,o),j=!0)},o(o){b(t.$$.fragment,o),b(l.$$.fragment,o),b(a.$$.fragment,o),b(i.$$.fragment,o),b($.$$.fragment,o),b(g.$$.fragment,o),b(p.$$.fragment,o),b(S.$$.fragment,o),b(H.$$.fragment,o),j=!1},d(o){o&&(c(s),c(n),c(e),c(f),c(m),c(d),c(I),c(A)),K(t,o),K(l,o),K(a,o),K(i,o),K($,o),K(g,o),K(p,o),K(S,o),K(H,o)}}}function cs(r){let t,s;return t=new dt({props:{title:"Проектируем Apache Kafka с умом",$$slots:{default:[$s]},$$scope:{ctx:r}}}),{c(){h(t.$$.fragment)},l(l){w(t.$$.fragment,l)},m(l,n){k(t,l,n),s=!0},p(l,[n]){const a={};n&2&&(a.$$scope={dirty:n,ctx:l}),t.$set(a)},i(l){s||(v(t.$$.fragment,l),s=!0)},o(l){b(t.$$.fragment,l),s=!1},d(l){K(t,l)}}}const lt="0.2";function os(r){return[`${pt}/slides/2025-04/kafka-planning`]}class xs extends at{constructor(t){super(),it(this,t,os,cs,nt,{})}}export{xs as component};
